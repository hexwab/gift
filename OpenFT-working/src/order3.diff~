? TODO
? auto.diff
? db-shutdown.diff
? dbname.diff
? dup.diff
? ft_search_db.c.b0rk
? ft_search_db.c.conf2
? ft_search_db.c.conflicted
? ft_search_db.c.orderworking
? ft_search_db.c.temp
? ft_search_db.c.vanilla
? ft_shost.c.unused
? ft_shost.h.unused
? ft_tokenize
? ft_tokenize.c
? ft_tokenize.h
? ft_tokenize.working
? ft_tokenize.working.c
? ft_xfer.c
? gmon.out
? handshake.diff
? hashfn.diff
? http_server.diff
? locate-ttl.diff
? netorg.diff
? netorg3.diff
? node.diff
? node_cache.diff
? node_cache2.diff
? order.diff
? order2.diff
? order3.diff
? order_full.diff
? queue.diff
? rlimit.diff
? search-bonus.diff
? search-separate.diff
? search-todo
? shutdown2.diff
? test
? unstable
? url.diff
Index: Makefile.am
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/Makefile.am,v
retrieving revision 1.4
diff -u -r1.4 Makefile.am
--- Makefile.am	26 Dec 2003 12:22:59 -0000	1.4
+++ Makefile.am	13 Jun 2004 23:15:53 -0000
@@ -32,6 +32,7 @@
 	ft_search_exec.c ft_search_exec.h \
 	ft_search_obj.c  ft_search_obj.h \
 	ft_netorg.c      ft_netorg.h \
+	ft_tokenize.c    ft_tokenize.h \
 	ft_transfer.c    ft_transfer.h \
 	ft_http.c        ft_http.h \
 	ft_http_client.c ft_http_client.h \
Index: ft_conf.h
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_conf.h,v
retrieving revision 1.27
diff -u -r1.27 ft_conf.h
--- ft_conf.h	26 Dec 2003 06:44:20 -0000	1.27
+++ ft_conf.h	13 Jun 2004 23:15:53 -0000
@@ -44,14 +44,21 @@
 #define FT_CFG_SEARCH_MINPEERS    ft_cfg_get_int("search/minpeers=8")
 #define FT_CFG_SEARCH_MAXPEERS    ft_cfg_get_int("search/peers=12")
 #define FT_CFG_SEARCH_TTL         ft_cfg_get_int("search/default_ttl=2")
+#define FT_CFG_LOCATE_TTL         ft_cfg_get_int("search/locate_ttl=3")
 #define FT_CFG_SEARCH_RESULTS     ft_cfg_get_int("search/max_results=800")
 #define FT_CFG_SEARCH_RESULTS_REQ ft_cfg_get_int("search/max_results_req=800")
-#define FT_CFG_MAX_TTL            ft_cfg_get_int("search/max_ttl=2")
+#define FT_CFG_MAX_TTL            ft_cfg_get_int("search/max_ttl=3")
 #define FT_CFG_MAX_RESULTS        FT_CFG_SEARCH_RESULTS
-#define FT_CFG_MAX_CHILDREN       ft_cfg_get_int("search/children=85")
+#define FT_CFG_MAX_CHILDREN       ft_cfg_get_int("search/children=100")
+#define FT_CFG_MIN_CHILDREN       ft_cfg_get_int("search/min_children=30")
 #define FT_CFG_MAX_CONNECTIONS    (30)
 #define FT_CFG_MAX_ACTIVE         ft_cfg_get_int("connections/max_active=-1")
 
+#define FT_CFG_PROMOTE_CHANCE     (0.1)
+#define FT_CFG_DEMOTE_CHANCE      (0.002)
+
+#define FT_CFG_MAX_ACTIVE         ft_cfg_get_int("connections/max_active=-1")
+
 #define FT_CFG_SEARCH_ENV_PATH    ft_cfg_get_path("search/env_path", "OpenFT/db")
 #define FT_CFG_SEARCH_ENV_CACHE   ft_cfg_get_int("search/env_cache=31457280")
 #define FT_CFG_SEARCH_ENV_PRIV    ft_cfg_get_int("search/env_priv=1")
Index: ft_conn.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_conn.c,v
retrieving revision 1.55
diff -u -r1.55 ft_conn.c
--- ft_conn.c	5 May 2004 04:42:42 -0000	1.55
+++ ft_conn.c	13 Jun 2004 23:15:53 -0000
@@ -20,6 +20,8 @@
 #include "ft_node_cache.h"
 #include "ft_conn.h"
 
+#include "ft_search_db.h"              /* automatic node promotion */
+
 #ifdef HAVE_SYS_TIME_H
 # include <sys/time.h>
 #endif /* HAVE_SYS_TIME_H */
@@ -54,6 +56,22 @@
  */
 static int max_active = -1;
 
+/**
+  * The number of 2 minute blocks we can go without a parent before we
+  * begin automatic search node promotion tests.
+  */
+#define IMPOVERISH_MIN (4)
+
+/**
+  * Ditto, but for seeing if our services as a search node are no longer
+  * required.
+  */
+#define SURPLUS_MIN (6)
+
+static unsigned int poverty_count = 0;
+
+static unsigned int surplus_count = 0;
+
 /*****************************************************************************/
 
 static BOOL drop_notalive (FTNode *node, void *udata)
@@ -202,6 +220,10 @@
 
 static BOOL get_nodes (FTNode *node, void *udata)
 {
+#if 0
+  //	ft_packet_sendva (FT_CONN(node), FT_NODELIST_REQUEST, 0, NULL);
+	ft_packet_sendva (FT_CONN(node), FT_NODELIST_REQUEST, 0, "hh", FT_NODE_SEARCH, 500);
+#else
 	FTPacket *pkt;
 
 	if (!(pkt = ft_packet_new (FT_NODELIST_REQUEST, 0)))
@@ -213,6 +235,7 @@
 	if (ft_packet_send (FT_CONN(node), pkt) < 0)
 		return FALSE;
 
+#endif
 	return TRUE;
 }
 
@@ -330,6 +353,125 @@
 
 /*****************************************************************************/
 
+static BOOL check_promote (void)
+{
+	float diceroll;
+	int ret;
+	
+	assert (!(openft->ninfo.klass & FT_NODE_SEARCH));
+	if (!(openft->klass_max & FT_NODE_SEARCH))
+		return FALSE;
+
+	diceroll = ((float)rand() / (RAND_MAX + 1.0));
+	
+	if (diceroll > FT_CFG_PROMOTE_CHANCE)
+		return FALSE;
+
+	/* if you're hap^H^H^Hfirewalled and you know it... */
+	if (openft->ninfo.port_openft == 0)
+		return FALSE;
+
+	/* insert other	tests here */
+
+	FT->warn (FT, "Automatically promoting to FT_NODE_SEARCH status");
+
+	if ((ret = ft_search_db_init (FT_CFG_SEARCH_ENV_PATH, FT_CFG_SEARCH_ENV_CACHE)))
+		openft->ninfo.klass |= FT_NODE_SEARCH;
+	else
+		FT->DBGFN (FT, "search db startup failed");
+	
+	surplus_count = 0;
+
+	return ret;
+}
+
+static BOOL drop_after_demotion (FTNode *node, void *udata)
+{
+	if (!node->ninfo.klass & FT_NODE_PARENT)
+		ft_session_stop (FT_CONN(node));
+	return TRUE;
+}
+
+static BOOL drop_children (FTNode *node, void *udata)
+{
+	ft_node_remove_class (node, FT_NODE_CHILD);
+	return TRUE;
+}
+
+static BOOL check_demote (void)
+{
+	int n, min;
+	float chance, diceroll;
+
+	assert (openft->ninfo.klass & FT_NODE_SEARCH);
+
+	/* Don't demote unless we automatically promoted earlier */
+	if (openft->klass_min & FT_NODE_SEARCH)
+		return FALSE;
+
+	n = ft_netorg_length (FT_NODE_CHILD, FT_NODE_CONNECTED);
+	min = FT_CFG_MIN_CHILDREN;
+
+	if (n >= min)
+	{
+		surplus_count = 0;
+		return FALSE;
+	}
+
+	/* wait a while for child acquisition */
+	if (++surplus_count < SURPLUS_MIN)
+		return FALSE;
+
+	/* 
+	 * This needs to be random so that newly-orphaned children
+	 * have time to locate a new parent before said parent demotes
+	 * itself too.
+	 *
+	 * This should become less critical as network size increases.
+	 */
+	chance = FT_CFG_DEMOTE_CHANCE;
+	chance *= ((float)min / (n + 1)); /* few children == more chance to demote */
+
+	/*
+	 * we haven't had any incoming connections yet; we might be
+         * firewalled but unaware of the fact...
+	 */
+	if (openft->ninfo.indirect)
+		chance *= 5; 
+
+	diceroll = ((float)rand() / (RAND_MAX + 1.0));
+
+	if (diceroll > chance)
+		return FALSE;
+	
+	/* OK, do it */
+	FT->DBGFN (FT, "demoting: firewalled=%d, children=%d, min=%d, surplus_count=%d",
+		   openft->ninfo.indirect, n, min, surplus_count);
+
+	openft->ninfo.klass &= ~FT_NODE_SEARCH;
+	ft_search_db_destroy ();
+	
+	/*
+	 * Drop all non-PARENT connections first.  FIXME: this might
+	 * not be necessary, and is yet another place where network
+	 * topology is hardcoded, but I'm trying it anyway in an
+	 * effort to remove demoted nodes as quickly as possible.
+	 */
+	ft_netorg_foreach (FT_NODE_USER, FT_NODE_CONNECTED, 0,
+			   FT_NETORG_FOREACH(drop_after_demotion), NULL);
+
+	/*
+	 * Remove CHILD status from any remaining connections.  Note
+	 * that this does *not* tell the remote node that we've done
+	 * so, thus causing problems if our PARENT is also our
+	 * CHILD...
+	 */
+	ft_netorg_foreach (FT_NODE_CHILD, FT_NODE_CONNECTED, 0,
+			       FT_NETORG_FOREACH(drop_children), NULL);
+	
+	return TRUE;
+}
+
 static int acquire_new_stuff (void)
 {
 	BOOL need_parents;
@@ -343,6 +485,35 @@
 	need_peers   = ft_conn_need_peers();
 	need_index   = ft_conn_need_index();
 
+	/* 
+	 * 4 possibilities here:
+	 * search orphan action
+	 * no     no     stable, do nothing
+	 * no     yes    try autopromotion
+	 * yes    no     check if we're no longer needed
+	 * yes    yes    wait for a parent (don't demote without one)
+	 *
+	 * In particular, this last case means that the minimum child
+	 * count is inapplicable on tiny networks with only one search
+	 * node.  
+	 */
+
+	if (openft->ninfo.klass & FT_NODE_SEARCH)
+	{
+		poverty_count = 0;
+
+		if (!need_parents)
+			check_demote ();
+	}
+	else 
+	{
+		if (!need_parents)
+			poverty_count = 0;
+		else
+			if (++poverty_count >= IMPOVERISH_MIN)
+				check_promote ();
+	}
+
 	/* nothing is needed, get out of here */
 	if (!need_parents && !need_peers && !need_index)
 		return 0;
@@ -573,7 +744,6 @@
 			return limit;
 		}
 
-
 		limit = (int)rlim.rlim_cur;
 	}
 #endif /* HAVE_SYS_RESOURCE_H */
@@ -589,15 +759,15 @@
 	/* the default (-1) asks us to make an educated guess */
 	if ((nconns = FT_CFG_MAX_ACTIVE) == -1)
 	{
-		if (!(openft->ninfo.klass & FT_NODE_SEARCH))
-			nconns = 600;
-		else
+		if (openft->klass_max & FT_NODE_SEARCH)
 		{
 			int nchildren = FT_CFG_MAX_CHILDREN;
 
 			/* 2n * (n / 3) */
 			nconns = (7 * nchildren) / 3;
 		}
+		if (nconns < 400)
+			nconns = 400;
 
 		FT->warn (FT, "guessing max_active=%d", nconns);
 	}
@@ -633,7 +803,7 @@
 	 * the long run, this is done to minimize the need to create TCP
 	 * connections that will not be desired.
 	 */
-	n = ft_netorg_foreach (FT_NODE_USER, FT_NODE_DISCONNECTED, 0,
+	n = ft_netorg_random (FT_NODE_USER, FT_NODE_DISCONNECTED, 0,
 	                       FT_NETORG_FOREACH(start_connection), &weight);
 
 	FT->DBGFN (FT, "began %i connections (remaining weight: %i)", n, weight);
@@ -660,18 +830,27 @@
 	int n;
 
 	if (!check_local_allow (node))
+	{
+		FT->DBGFN (FT, "%s: not local", ft_node_fmt (node));
 		return FALSE;
+	}
 
 	/* we won't authorize a duplicate connection */
 	if (node->state != FT_NODE_DISCONNECTED)
+	{
+		FT->DBGFN (FT, "%s: dup", ft_node_fmt (node));
 		return FALSE;
+	}
 
 	if (outgoing)
 	{
 		/* refuse outbound connections when we suspect the version may be
 		 * outdated...let them come to us to prove otherwise */
 		if (node->version && FT_VERSION_LT(node->version, FT_VERSION_LOCAL))
+		{
+			FT->DBGFN (FT, "%s: outdated outbound", ft_node_fmt (node));
 			return FALSE;
+		}
 	}
 
 	/* make sure we honor FT_CFG_MAX_ACTIVE, when set */
@@ -680,13 +859,19 @@
 		n = ft_netorg_length (FT_NODE_CLASSANY, FT_NODE_CONNECTED);
 
 		if (n >= max_active)
+		{
+			FT->DBGFN (FT, "%s: max_active hit", ft_node_fmt (node));
 			return FALSE;
+		}
 
 		/* when we only have 100 connections left, start refusing the broken
 		 * 0.2.0.0 nodes (and 0.2.0.1 out of CVS) */
 		if ((node->version > 0 && node->version <= OPENFT_0_2_0_1) &&
 		    (n + 100 >= max_active))
+		{
+			FT->DBGFN (FT, "%s: semi-outdated", ft_node_fmt (node));
 			return FALSE;
+		}
 	}
 
 	return TRUE;
Index: ft_http_server.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_http_server.c,v
retrieving revision 1.68
diff -u -r1.68 ft_http_server.c
--- ft_http_server.c	11 May 2004 21:25:18 -0000	1.68
+++ ft_http_server.c	13 Jun 2004 23:15:54 -0000
@@ -46,6 +46,22 @@
 
 /*****************************************************************************/
 
+static char *version_string = NULL;
+
+char *ft_http_server_version (void)
+{
+	if (!version_string)
+	{
+		version_string = stringf_dup ("OpenFT/%i.%i.%i.%i (%s)",
+			     OPENFT_MAJOR, OPENFT_MINOR,
+			     OPENFT_MICRO, OPENFT_REV,
+			     platform_version ()
+			     );
+	}
+
+	return version_string;
+}
+
 /*
  * Accept a new incoming HTTP connection.  Please note that this does not
  * necessarily mean this is a download or an upload, merely that it is an
@@ -163,6 +179,8 @@
 	if (!(host_path = file_host_path (share->path)))
 		return FALSE;
 
+	file_unlink (host_path);
+
 	if (!(f = fopen (host_path, "wb")))
 		return FALSE;
 
@@ -359,7 +377,17 @@
 			 * need to actually ask giFT for authorization.
 			 */
 			if ((share = FT->share_lookup (FT, SHARE_LOOKUP_HPATH, reqstr)))
+			{
+				FTNode *node;
 				ret = FT->upload_auth (FT, net_ip_str (c->host), share, auth_info);
+				
+				/* allow our parent a free slot */
+				if (ret == UPLOAD_AUTH_MAX &&
+				    (node = ft_netorg_lookup (c->host)) &&
+				    (node->state & FT_NODE_CONNECTED) &&
+				    (node->ninfo.klass & FT_NODE_PARENT))
+				ret = UPLOAD_AUTH_ALLOW;
+			}
 			else
 				ret = UPLOAD_AUTH_NOTSHARED;
 		}
@@ -470,8 +498,9 @@
 
 	if (strcmp (req->request, "/nodes") == 0)
 	{
-		dataset_insertstr (&reply->keylist, "X-Class",
-		                   stringf ("%d", openft->ninfo.klass));
+		dataset_insertstr (&reply->keylist, "X-Class", stringf ("%d", openft->ninfo.klass));
+		dataset_insertstr (&reply->keylist, "X-ClassMin", stringf ("%d", openft->klass_min));
+		dataset_insertstr (&reply->keylist, "X-ClassMax", stringf ("%d", openft->klass_max));
 	}
 
 	if (openft->ninfo.alias)
@@ -496,11 +525,16 @@
 	 * protocol as the protocol-specific status.
 	 */
 	buf_retry = stringf_dup ("%u", (60 * SECONDS));
-	buf_pos   = stringf_dup ("%u of %u",
-	                         auth_info->queue_pos, auth_info->queue_ttl);
+
+	if (auth_info->queue_pos && auth_info->queue_ttl)
+	{
+		buf_pos = stringf_dup ("%u of %u",
+				       auth_info->queue_pos,
+				       auth_info->queue_ttl);
+		dataset_insertstr (&reply->keylist, "X-QueuePosition", buf_pos);
+	}
 
 	dataset_insertstr (&reply->keylist, "X-ShareStatus",   "Queued");
-	dataset_insertstr (&reply->keylist, "X-QueuePosition", buf_pos);
 	dataset_insertstr (&reply->keylist, "X-QueueRetry",    buf_retry);
 
 	free (buf_retry);
@@ -788,7 +822,12 @@
 	assert (f != NULL);
 
 	/* overflowing shouldnt be possible, but just in case.... */
-	assert (c->start + c->transmit < c->stop);
+	//	assert (c->start + c->transmit < c->stop);
+	
+	if (c->start + c->transmit >= c->stop) {
+		ft_transfer_stop_status (xfer, SOURCE_CANCELLED, "Overflow");
+		return;
+	}
 
 	/*
 	 * Ask giFT for the size we should send.  If this returns 0, the upload
Index: ft_netorg.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_netorg.c,v
retrieving revision 1.38
diff -u -r1.38 ft_netorg.c
--- ft_netorg.c	8 May 2004 02:37:27 -0000	1.38
+++ ft_netorg.c	13 Jun 2004 23:15:54 -0000
@@ -474,6 +474,61 @@
 
 /*****************************************************************************/
 
+static void randomize_conn_iptr (ft_state_t state)
+{
+	struct conn_list *clist = NULL;
+	int new_pos;
+
+	if (!(clist = get_conn_list (state)))
+		return;
+
+	if (clist->list == NULL || clist->count == 0)
+		return;
+
+	/* set clist->iptr to random point in list */
+	new_pos = rand() % clist->count;
+	clist->iptr = list_nth (clist->list->list, new_pos);
+
+	/* just in case anything went wrong */
+	if (clist->iptr == NULL)
+		clist->iptr = (clist->list ? clist->list->list : NULL);
+}
+
+int ft_netorg_random (ft_class_t klass, ft_state_t state, int iter,
+                      FTNetorgForeach func, void *udata)
+{
+	int looped = 0;
+
+	if (!func)
+		return 0;
+
+	if (state)
+	{
+		randomize_conn_iptr (state);
+		looped = foreach_list (klass, state, iter, func, udata);
+	}
+	else
+	{
+		/* state = 0x00 indicates that all states should be processed,
+		 * therefore requiring multiple calls to foreach_list that are
+		 * capable of persisting iteration data */
+		randomize_conn_iptr (FT_NODE_CONNECTED);
+		randomize_conn_iptr (FT_NODE_CONNECTING);
+		randomize_conn_iptr (FT_NODE_DISCONNECTED);
+
+		iter_state (klass, FT_NODE_CONNECTED, iter, &looped, func, udata);
+		iter_state (klass, FT_NODE_CONNECTING, iter, &looped, func, udata);
+		iter_state (klass, FT_NODE_DISCONNECTED, iter, &looped, func, udata);
+	}
+
+	if (iter)
+		assert (looped <= iter);
+
+	return looped;
+}
+
+/*****************************************************************************/
+
 #ifdef VERIFY_NETORG_LENGTH
 static BOOL length_dummy (FTNode *node, void *udata)
 {
Index: ft_netorg.h
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_netorg.h,v
retrieving revision 1.13
diff -u -r1.13 ft_netorg.h
--- ft_netorg.h	25 Oct 2003 23:55:21 -0000	1.13
+++ ft_netorg.h	13 Jun 2004 23:15:54 -0000
@@ -105,6 +105,14 @@
                        FTNetorgForeach func, void *udata);
 
 /**
+ * Does the same as ft_netorg_foreach but starts at a random position in each
+ * list instead of the last access / beginning.
+ */
+int ft_netorg_random (ft_class_t klass, ft_state_t state, int iter,
+                      FTNetorgForeach func, void *udata);
+
+
+/**
  * Efficient means of accessing the total length of the list that would be
  * iterated over using a similar call to ::ft_netorg_foreach.  This routine
  * accesses a separately maintained data structure which has the length
Index: ft_node.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_node.c,v
retrieving revision 1.57
diff -u -r1.57 ft_node.c
--- ft_node.c	9 May 2004 00:14:53 -0000	1.57
+++ ft_node.c	13 Jun 2004 23:15:55 -0000
@@ -94,6 +94,7 @@
 	ft_node_set_http_port (node, http_port);
 	ft_node_set_class     (node, klass);
 
+	//	FT->dbg (FT, "registered %s: indirect=%d", ft_node_fmt (node), node->ninfo.indirect);
 	node->last_session = vitality;
 	node->uptime       = uptime;
 	node->version      = ver;
@@ -695,9 +696,14 @@
 		if (node->session)
 		{
 			if (node->session->verified == FALSE)
+			{	
+				FT->dbg (FT, "%s unverified", ft_node_fmt (node));
 				return TRUE;
+			}
 		}
 	}
+	//	if (ret)
+	//		FT->dbg (FT, "%s firewalled", ft_node_fmt (node));
 
 	return ret;
 }
Index: ft_node_cache.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_node_cache.c,v
retrieving revision 1.17
diff -u -r1.17 ft_node_cache.c
--- ft_node_cache.c	2 Nov 2003 12:09:06 -0000	1.17
+++ ft_node_cache.c	13 Jun 2004 23:15:55 -0000
@@ -31,6 +31,22 @@
 
 /*****************************************************************************/
 
+struct cache_state {
+	FILE    *f;
+	BOOL     error;
+	BOOL     unconfirmed;
+	ft_class_t klass;
+};
+
+static ft_class_t class_priority[]=
+{
+	FT_NODE_INDEX,
+	FT_NODE_SEARCH,
+	FT_NODE_USER
+};
+
+#define PRIO_LEN (sizeof(class_priority) / sizeof(ft_class_t))
+
 static int import_cache (FILE *f, char *path)
 {
 	FTNode        *node;
@@ -137,11 +153,17 @@
 
 /*****************************************************************************/
 
-static int write_node_cache (FTNode *node, FILE *f)
+static int write_node (FTNode *node, struct cache_state *state)
 {
 	time_t     vitality;
 	time_t     uptime;
 	ft_class_t klass;
+	int        wrote;
+
+	/* make sure the class we're interested in is the most
+	 * significant class this node has */
+	if ((node->ninfo.klass & FT_NODE_CLASSPRI_MASK) >= (state->klass << 1))
+		return FALSE;
 
 	/* no reason to write out firewalled nodes or users which we would
 	 * deny a connection to anyway... */
@@ -159,6 +181,11 @@
 	else
 		vitality = node->last_session;
 
+	/* Don't store nodes we've never connected to, unless we're
+	   desperate */
+	if (state->unconfirmed ^ !vitality)
+		return FALSE;
+
 	/*
 	 * Calculate the current uptime by determining the last known recorded
 	 * uptime (set at session close or when reading from the nodes file) and
@@ -171,73 +198,65 @@
 	 * and parent relationships) */
 	klass = ft_node_class (node, FALSE);
 
-	fprintf (f, "%li %li %s %hu %hu %hu %u\n",
+	wrote = fprintf (state->f, "%li %li %s %hu %hu %hu %u\n",
 	         (long)vitality, (long)uptime, net_ip_str (node->ninfo.host),
 	         node->ninfo.port_openft, node->ninfo.port_http,
 	         (unsigned short)klass, (unsigned int)node->version);
 
-	return TRUE;
-}
-
-static BOOL write_node_index (FTNode *node, FILE *f)
-{
-	return write_node_cache (node, f);
-}
-
-static BOOL write_node_search (FTNode *node, FILE *f)
-{
-	if (node->ninfo.klass & FT_NODE_INDEX)
-		return FALSE;
-
-	return write_node_cache (node, f);
-}
+	if (!wrote)
+	{
+		if (!state->error)
+			FT->err (FT, "error writing nodes cache: %s", platform_error ());
 
-static BOOL write_node_user (FTNode *node, FILE *f)
-{
-	if (node->ninfo.klass & FT_NODE_SEARCH)
+		state->error = TRUE;
+		
 		return FALSE;
-
-	return write_node_cache (node, f);
+	}
+		
+	return TRUE;
 }
 
 static int rewrite_cache (char *path)
 {
-	FILE *f;
 	char *pathtmp;
 	int   nodes;
 	int   remaining;
+	int   i;
 
+	struct cache_state state;
+	
 	/* use a temp path so we dont clobber the original if something goes
 	 * haywire */
 	if (!(pathtmp = stringf ("%s.tmp", path)))
 		return 0;
 
-	if (!(f = fopen (pathtmp, "w")))
+	if (!(state.f = fopen (pathtmp, "w")))
 	{
 		FT->err (FT, "can't create %s: %s", pathtmp, GIFT_STRERROR());
 		return 0;
 	}
 
-	/* loop through all nodes and write them out to the nodes cache */
-	nodes  = ft_netorg_foreach (FT_NODE_INDEX, FT_NODE_STATEANY, 0,
-	                            FT_NETORG_FOREACH(write_node_index), f);
-	nodes += ft_netorg_foreach (FT_NODE_SEARCH, FT_NODE_STATEANY, 0,
-	                            FT_NETORG_FOREACH(write_node_search), f);
-
-	/* determine the remaining number of nodes we can write to the cache */
-	remaining = FT_CFG_NODES_CACHE_MAX - nodes;
+	nodes = 0;
+	state.error = FALSE;
 
-	/* fill in the rest with user nodes... */
-	if (remaining > 0)
+	for (i = 0; i < PRIO_LEN * 2; i++)
 	{
-		ft_netorg_foreach (FT_NODE_USER, FT_NODE_STATEANY, remaining,
-		                   FT_NETORG_FOREACH(write_node_user), f);
+		remaining = FT_CFG_NODES_CACHE_MAX - nodes;
+		if (remaining <= 0)
+			break;
+
+		state.klass = class_priority[i % PRIO_LEN];
+		state.unconfirmed = (i >= PRIO_LEN);
+		nodes += ft_netorg_foreach (state.klass, FT_NODE_STATEANY, remaining,
+	                            FT_NETORG_FOREACH(write_node), &state);
 	}
 
-	fclose (f);
+	if (fclose (state.f))
+		state.error = TRUE;
 
 	/* get rid of the temp path */
-	file_mv (pathtmp, path);
+	if (!state.error)
+		file_mv (pathtmp, path);
 
 	return nodes;
 }
Index: ft_openft.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_openft.c,v
retrieving revision 1.58
diff -u -r1.58 ft_openft.c
--- ft_openft.c	27 Dec 2003 01:57:26 -0000	1.58
+++ ft_openft.c	13 Jun 2004 23:15:55 -0000
@@ -156,7 +156,7 @@
 		}
 
 		/* lets not make a big fuss out of this setting */
-		openft->klass_alw &= ~FT_NODE_SEARCH;
+		openft->klass_max &= ~FT_NODE_SEARCH;
 	}
 
 #ifndef USE_LIBDB
@@ -209,10 +209,11 @@
 	openft->ninfo.alias       =      STRDUP(FT_CFG_NODE_ALIAS);
 	openft->ninfo.port_openft =  (in_port_t)FT_CFG_NODE_PORT;
 	openft->ninfo.port_http   =  (in_port_t)FT_CFG_NODE_HTTP_PORT;
-	openft->klass_alw         = (ft_class_t)FT_CFG_NODE_CLASS_ALLOW;
+	openft->klass_min         = (ft_class_t)FT_CFG_NODE_CLASS;
+	openft->klass_max         = (ft_class_t)FT_CFG_NODE_CLASS_ALLOW;
 
-	/* hmm, maybe ninfo.indirect is a bad idea? */
-	openft->ninfo.indirect = BOOL_EXPR (openft->ninfo.port_openft == 0);
+	/* nope, ninfo.indirect is not a bad idea */
+	openft->ninfo.indirect = 1;
 
 	/* make sure that the parameters supplied above dont conflict in some way */
 	if (!(clamp_openft_params (p, openft)))
@@ -303,6 +304,8 @@
 	/* disconnect everyone for cleanliness */
 	ft_netorg_clear (FT_NETORG_FOREACH(cleanup_conn), NULL);
 
+	ft_search_db_destroy ();
+
 	/* cleanup */
 	config_free (openft->cfg);
 	tcp_close (openft->bind_openft);
Index: ft_openft.h
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_openft.h,v
retrieving revision 1.48
diff -u -r1.48 ft_openft.h
--- ft_openft.h	23 Dec 2003 04:22:35 -0000	1.48
+++ ft_openft.h	13 Jun 2004 23:15:55 -0000
@@ -100,7 +100,8 @@
 	TCPC            *bind_openft;      /**< Listen on the OpenFT port */
 	TCPC            *bind_http;        /**< Listen on the OpenFT HTTP port */
 
-	ft_class_t       klass_alw;        /**< Class mask for auto-promotion */
+	ft_class_t       klass_min;        /**< Automatic class management */
+	ft_class_t       klass_max;
 
 	unsigned int     avail;            /**< Cached upload availability */
 
Index: ft_search.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_search.c,v
retrieving revision 1.58
diff -u -r1.58 ft_search.c
--- ft_search.c	22 May 2004 07:22:19 -0000	1.58
+++ ft_search.c	13 Jun 2004 23:15:56 -0000
@@ -158,7 +158,12 @@
 	 * waiting on.  If 0, we will be resposnible for tidying up the search
 	 * object.
 	 */
-	if (ft_search_rcvdfrom (srch, result->parent->host) == 0)
+	int left;
+	
+	left = ft_search_rcvdfrom (srch, result->parent->host);
+	FT->dbg (FT, "got sentinel from %s: %d left",  net_ip_str (result->parent->host), left);
+
+	if (left == 0)
 		ft_search_finish (srch);
 
 	/* uhh, what defines failure for us? */
@@ -307,10 +312,15 @@
 	type = search->params.type;
 
 #ifdef FT_SEARCH_PARANOID
-	if (FT_SEARCH_TYPE(type) == FT_SEARCH_FILENAME)
+	if (FT_SEARCH_METHOD(type) == FT_SEARCH_FILENAME)
 		type |= FT_SEARCH_HIDDEN;
 #endif /* FT_SEARCH_PARANOID */
 
+#ifdef FT_SEARCH_DIRECT
+	if (FT_SEARCH_METHOD(type) == FT_SEARCH_FILENAME)
+		type |= FT_SEARCH_COUNT;
+#endif	
+
 	if (!(pkt = ft_packet_new (FT_SEARCH_REQUEST, 0)))
 		return FALSE;
 
Index: ft_search_db.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_search_db.c,v
retrieving revision 1.108
diff -u -r1.108 ft_search_db.c
--- ft_search_db.c	14 Apr 2004 10:19:35 -0000	1.108
+++ ft_search_db.c	13 Jun 2004 23:15:57 -0000
@@ -26,6 +26,7 @@
 #include "md5.h"
 
 #include "ft_search_db.h"
+#include "ft_tokenize.h"
 
 /*****************************************************************************/
 
@@ -55,6 +56,26 @@
 /* #define SEARCH_DB_BENCHMARK */
 
 /*
+ * Primitive interactive querying when using the test suite.
+ */
+/* #define INTERACTIVE */
+
+/* 
+ * Whenever a host is removed, check the entire tokens index to ensure
+ * there are no stray tokens left from that host. Expensive, use with
+ * caution.
+ */
+/* #define PARANOID */
+
+/*
+ * Track duplicates (identical files shared by the same host)
+ * explicitly, and bail at the first hint of inconsistency. Beware:
+ * this can abort if a remote node requests removal of a file they
+ * never shared.
+ */
+/* #define CHECK_DUPS */
+
+/*
  * Sync all databases after changes have been made to ease debugging.  This
  * greatly hurts performance and should not be enabled for every day usage.
  */
@@ -67,16 +88,23 @@
  *
  * NOTE:
  *
- * It has been determined that this causes a great deal of problems in DB 4.1
- * and presumably 4.0.  Once you create a database with a custom hash
- * function, it seems you no longer have the ability to remove it, even if
- * you reset the hash function prior to calling DB->remove.  It appears as
- * though DB 3.x is unaffected, but I have no further information than that.
+ * It has been determined that this causes a great deal of problems in
+ * DB 4.1 and presumably 4.0.  Once you create a database with a
+ * custom hash function in a file containing multiple databases, it
+ * seems you no longer have the ability to remove it, even if you
+ * reset the hash function prior to calling DB->remove.  It appears as
+ * though DB 3.x is unaffected, but I have no further information than
+ * that.
  *
  * UPDATE:
  *
  * We have discovered a work-around to this problem that is documented in
  * direct_md5_hash.
+ *
+ * UPDATE 2:
+ *
+ * The workaround is currently not required since the share data was
+ * moved into a single database.
  */
 #define SEARCH_DB_DIRHASH
 
@@ -149,7 +177,12 @@
 {
 	FTSearchDB   *sdb;                 /* raw pointer into the database */
 	unsigned char md5[16];
-};
+	unsigned char order;
+}
+#ifdef __GNUC__
+__attribute ((packed)); /* avoid alignment padding */
+#endif
+;
 
 /*****************************************************************************/
 
@@ -162,6 +195,7 @@
 struct sharedata_data
 {
 	off_t          size;               /* file size */
+	u_int16_t      order;              /* offset of order list */
 	u_int16_t      path;               /* offset of path */
 	u_int16_t      mime;               /* offset of mime type */
 	u_int16_t      meta;               /* offset of meta data */
@@ -233,7 +267,7 @@
 static BOOL db_remove_host_timer (FTSearchDB *sdb);
 static BOOL db_remove_sharedata (FTSearchDB *sdb, unsigned char *md5);
 static BOOL db_remove_shareidx (FTSearchDB *sdb, unsigned char *md5);
-static Share *db_lookup_md5 (FTSearchDB *sdb, unsigned char *md5);
+static Share *db_lookup_md5 (FTSearchDB *sdb, unsigned char *md5, uint8_t **order);
 static BOOL db_close (FTSearchDB *sdb, BOOL rm);
 static BOOL db_sync (FTSearchDB *sdb);
 static BOOL db_abort (FTSearchDB *sdb);
@@ -249,6 +283,9 @@
 
 	node->session->search_db = sdb;
 	sdb->node = node;
+#ifdef CHECK_DUPS
+	sdb->dups = NULL;
+#endif
 
 	return sdb;
 }
@@ -725,6 +762,12 @@
 	           FT_CFG_SEARCH_MINPEERS, FT_CFG_SEARCH_MAXPEERS,
 	           FT_CFG_MAX_CHILDREN, FT_CFG_SEARCH_TTL, FT_CFG_SEARCH_RESULTS);
 
+#ifdef SEARCH_DB_BENCHMARK
+#ifndef OPENFT_TEST_SUITE
+	FT->DBGFN (FT, "BENCHMARKING ON!");
+#endif
+#endif
+
 	if ((ret = env_search->set_cachesize (env_search, c_gbytes, c_bytes, 0)))
 	{
 		ERR_DB("DB_ENV->set_cachesize", ret);
@@ -747,8 +790,10 @@
 		return FALSE;
 	}
 
+#ifndef SEARCH_DB_BENCHMARK
 	if (!(remove_queue = array_new (NULL)))
 		return FALSE;
+#endif
 
 	return TRUE;
 }
@@ -763,6 +808,26 @@
 	clean_db_path (envpath);
 }
 
+#ifdef CHECK_DUPS
+static void free_dups (FTSearchDB *sdb)
+{
+	void *elem;
+	int count = 0;
+	
+	while ((elem = array_pop (&sdb->dups)))
+	{
+		free (elem);
+		count++;
+	}
+
+	if (count)
+		FT->DBGFN (FT, "%s: %d duplicates freed",
+			   sdb->share_idx_name, count);
+
+	array_unset (&sdb->dups);
+}
+#endif
+
 /*****************************************************************************/
 
 static u_int16_t serialize_fld (struct sharedata_data *datarec,
@@ -800,7 +865,7 @@
 }
 
 static int serialize_record (DBT *data, Hash *hash, uint32_t *tokens,
-                             Share *share)
+			     uint8_t *order, Share *share)
 {
 	static struct sharedata_data datarec;
 
@@ -810,8 +875,9 @@
 	datarec.size = share->size;
 
 	/* copy the variably sized fields */
-	datarec.path = serialize_fld (&datarec, share->path, STRLEN_0(share->path));
-	datarec.mime = serialize_fld (&datarec, share->mime, STRLEN_0(share->mime));
+	datarec.order = serialize_fld (&datarec, order, STRLEN_0(order));
+	datarec.path  = serialize_fld (&datarec, share->path, STRLEN_0(share->path));
+	datarec.mime  = serialize_fld (&datarec, share->mime, STRLEN_0(share->mime));
 
 	datarec.meta = datarec.data_len;
 	share_foreach_meta (share, DS_FOREACH(sharedata_meta), &datarec);
@@ -847,7 +913,7 @@
 }
 
 static Share *unserialize_record (FTSearchDB *sdb, unsigned char *md5,
-                                  struct sharedata_data *datarec)
+                                  struct sharedata_data *datarec, uint8_t **order)
 {
 	Share *share;
 
@@ -865,6 +931,9 @@
 	             datarec->data + datarec->meta,
 	             datarec->data_len - datarec->meta);
 
+	if (order)
+		*order = STRDUP (datarec->data + datarec->order);
+
 	return share;
 }
 
@@ -923,7 +992,7 @@
 }
 
 static BOOL db_insert_sharedata (FTSearchDB *sdb, Hash *hash,
-                                 uint32_t *tokens, Share *share)
+                                 uint32_t *tokens, uint8_t *order, Share *share)
 {
 	static struct sharedata_key keyrec;
 	DB *dbp;
@@ -949,18 +1018,20 @@
 	key.size = sizeof (keyrec);
 
 	/* get the complete serialized record */
-	if (!serialize_record (&data, hash, tokens, share))
+	if (!serialize_record (&data, hash, tokens, order, share))
 		return FALSE;
 
 	/* insert a unique entry, resulting in an error if data already exists at
 	 * this key */
 	if ((ret = dbp->put (dbp, NULL, &key, &data, DB_NOOVERWRITE)))
 	{
-		ERR_DB_SDB("DB->put", ret, sdb);
-
 		assert (ret == DB_KEYEXIST);
+#ifdef CHECK_DUPS
+		array_push (&sdb->dups, md5_dup (keyrec.md5));
+#else
 		FT->DBGFN (FT, "duplicate MD5 %s (%s)",
 		           md5_fmt (keyrec.md5), sdb->share_idx_name);
+#endif
 
 		return FALSE;
 	}
@@ -1014,6 +1085,7 @@
 	DBT  key;
 	DBT  data;
 	int  ret;
+	int  i;
 
 	if (!(dbp = db_tokenidx()))
 		return FALSE;
@@ -1037,11 +1109,12 @@
 
 	/* insert one record for each token in the stream, effectively
 	 * "pre-searching" for this file */
-	for (; tokens && *tokens; tokens++)
+	for (i=0; tokens && *tokens; i++, tokens++)
 	{
 		/* key.data points to &keyrec, so this is actually going to modify
 		 * the data libdb is seeing */
 		keyrec.token = *tokens;
+		datarec.order = i + ORDER_MIN;
 
 		if ((ret = dbcp->c_put (dbcp, &key, &data, DB_KEYFIRST)))
 		{
@@ -1060,6 +1133,7 @@
 {
 	Hash     *hash;
 	uint32_t *tokens;
+	uint8_t  *order;
 	BOOL      success;
 
 	/* make sure the master databases are open and ready to go */
@@ -1069,16 +1143,18 @@
 	if (!(hash = share_get_hash (share, "MD5")))
 		return FALSE;
 
-	if (!(tokens = ft_search_tokenizef (share)))
+	if (!(tokens = ft_tokenize_share (share, &order)))
 		return FALSE;
 
+	success = TRUE;
+
 	/*
 	 * Insert into the global primary and secondary databases, as well as the
 	 * host-specific primary database.  See ft_search_db.h for more details
 	 * on exactly how this stuff is designed, if you're willing to believe it
 	 * was designed at all :)
 	 */
-	if ((success = db_insert_sharedata (sdb, hash, tokens, share)))
+	if (db_insert_sharedata (sdb, hash, tokens, order, share))
 	{
 		success = db_insert_shareidx (sdb, hash, tokens);
 		assert (success == TRUE);
@@ -1107,6 +1183,7 @@
 	}
 
 	free (tokens);
+	free (order);
 
 	return success;
 }
@@ -1274,12 +1351,49 @@
 	if (!db_md5idx() || !db_tokenidx())
 		return FALSE;
 
+	FT->DBGFN(FT,"%s: single_remove %s", ft_node_fmt (sdb->node), md5_fmt(md5));
+
+#ifdef CHECK_DUPS
+	/* dup lookup first; yes, this is horribly inefficient,
+	 * and despite it probably being safe to check only if lookup
+	 * fails, I'm being cautious for now
+	 */
+	if (sdb->dups)
+	{
+		int i, len;
+		len = array_count (&sdb->dups);
+		for (i=0; i<len; i++)
+		{
+			unsigned char *dup;
+			dup = array_index (&sdb->dups, i);
+			assert (dup);
+			if (!memcmp (md5, dup, 16))
+			{
+				/* Now remove this dup, and don't touch the db */
+				free (dup);
+				array_splice (&sdb->dups, i, 1, NULL);
+
+#ifndef SEARCH_DB_BENCHMARK
+				FT->DBGFN (FT, "%s: removed duplicate %s", 
+					   sdb->share_idx_name, md5_fmt (md5));
+#endif
+
+				assert (len - array_count (&sdb->dups) == 1);
+
+				/* FIXME: stats */
+
+				return TRUE;
+			}
+		}
+	}
+#endif
+
 	/*
 	 * Grab the per-user data entry at the supplied key, which will contain
 	 * enough information to get the token list for removal from the
 	 * secondary database and the size for statistics purposes.
 	 */
-	if (!(share = db_lookup_md5 (sdb, md5)))
+	if (!(share = db_lookup_md5 (sdb, md5, NULL)))
 	{
 		FT->DBGFN (FT, "%s: unable to locate md5 %s for removal",
 		           ft_node_fmt (sdb->node), md5_fmt (md5));
@@ -1299,19 +1413,40 @@
 	 * drudging on as long as possible just to try to tidy up the database
 	 * as much as possible.  Perhaps this is unwise?
 	 */
-	failure  = ! db_remove_md5idx    (sdb, md5);
-	failure |= ! db_remove_sharedata (sdb, md5);
-	failure |= ! db_remove_shareidx  (sdb, md5);
+	if ((failure  = ! db_remove_md5idx    (sdb, md5))) 
+	{
+		FT->DBGFN (FT, "%s: remove_md5idx failed for '%s'", 
+			   ft_node_fmt (sdb->node), md5_fmt (md5));
+	}
+	if (! db_remove_sharedata (sdb, md5))
+	{
+		FT->DBGFN (FT, "%s: remove_sharedata failed for '%s'", 
+			   ft_node_fmt (sdb->node), md5_fmt (md5));
+		failure = TRUE;
+	}
+	if (! db_remove_shareidx  (sdb, md5))
+	{
+		FT->DBGFN (FT, "%s: remove_shareidx failed for '%s'", 
+			   ft_node_fmt (sdb->node), md5_fmt (md5));
+		failure = TRUE;
+	}
 
 	/* tokenize so that we know exactly what we're supposed to be removing
 	 * from the secondary database */
-	if (!(tokens = ft_search_tokenizef (share)))
-		failure = TRUE;
+
+	if (!(tokens = ft_tokenize_share (share, NULL)))
+		db_abort (sdb);
 	else
 	{
 		/* attempt to remove each token individually from the secondary
 		 * token index */
-		failure |= ! db_remove_tokenidx (sdb, tokens, md5);
+		if (! db_remove_tokenidx (sdb, tokens, md5))
+		{
+			FT->DBGFN (FT, "%s: remove_tokenidx failed for '%s'", 
+				   ft_node_fmt (sdb->node), md5_fmt (md5));
+			failure = TRUE;
+		}
+
 		free (tokens);
 	}
 
@@ -1322,6 +1457,60 @@
 	return !failure;
 }
 
+#ifdef PARANOID
+static void check_tokens (FTSearchDB *sdb)
+{
+	DB  *dbp;
+	DBC *dbcp;
+	int  ret;
+	DBT  key;
+	DBT  data;
+	struct tokenidx_key *keyrec;
+	struct tokenidx_data *datarec;
+	int  count = 0;
+
+	if (!(dbp = db_tokenidx()))
+		db_abort (sdb);
+	
+	FT->DBGFN (FT, "checking tokens idx after removing %p", sdb);
+
+	if ((ret = dbp->cursor (dbp, NULL, &dbcp, 0)) || !dbcp)
+	{
+		ERR_DB_SDB("DB->cursor", ret, sdb);
+		return;
+	}
+
+	memset (&key, 0, sizeof (key));
+	memset (&data, 0, sizeof (data));
+
+	while (!(ret = dbcp->c_get (dbcp, &key, &data, DB_NEXT)))
+	{
+		assert (key.size == sizeof (*keyrec));
+		assert (data.size == sizeof (*datarec));
+
+		keyrec = key.data;
+		datarec = data.data;
+		
+		if (datarec->sdb == sdb)
+			db_abort (sdb);
+
+		count++;
+	}
+
+	if (ret != DB_NOTFOUND)
+	{
+		ERR_DB_SDB("DBcursor->c_get", ret, sdb);
+		db_abort (sdb);
+	}
+
+	if ((ret = dbcp->c_close (dbcp)))
+		ERR_DB_SDB("DBcursor->c_close", ret, sdb);
+
+	FT->DBGFN (FT, "all done (%d tokens checked)", count);
+
+}
+#endif
+
 /*****************************************************************************/
 
 static BOOL db_remove_host_init (FTSearchDB *sdb)
@@ -1365,6 +1554,14 @@
 	/* close and remove db_shareidx */
 	db_close (sdb, TRUE);
 
+#ifdef PARANOID
+	check_tokens (sdb);
+#endif
+
+#ifdef CHECK_DUPS
+	free_dups (sdb);
+#endif
+
 	/* clean up the search database handle allocated to the node structure */
 	search_db_free (sdb);
 }
@@ -1639,7 +1836,7 @@
 
 /*****************************************************************************/
 
-static Share *db_lookup_md5 (FTSearchDB *sdb, unsigned char *md5)
+static Share *db_lookup_md5 (FTSearchDB *sdb, unsigned char *md5, uint8_t **order)
 {
 	static struct sharedata_key   keyrec;
 	static struct sharedata_data *datarec;
@@ -1663,6 +1860,31 @@
 
 	if ((ret = dbp->get (dbp, NULL, &key, &data, 0)))
 	{
+		assert (ret == DB_NOTFOUND);
+
+#ifdef CHECK_DUPS
+		/* make sure we actually have some dups */
+		if (!sdb->dups)
+			db_abort (sdb);
+
+		{
+			int i, len;
+			len = array_count (&sdb->dups);
+			for (i=0; i<len; i++)
+			{
+				unsigned char *dup;
+				dup = array_index (&sdb->dups, i);
+				assert (dup);
+				if (!memcmp (md5, dup, 16))
+					break;
+			}
+			
+			/* abort if we didn't find it in the dups list either */
+			if (i == len)
+				db_abort (sdb);
+		}
+#endif
+
 		ERR_DB_SDB("DB->get", ret, sdb);
 		return NULL;
 	}
@@ -1676,7 +1898,7 @@
 	 * to be called to gaurantee we are gathering the exact token stream that
 	 * was created at insert.
 	 */
-	if (!(share = unserialize_record (sdb, md5, datarec)))
+	if (!(share = unserialize_record (sdb, md5, datarec, order)))
 		return NULL;
 
 	return share;
@@ -1749,7 +1971,7 @@
 	 * completely unserialize the original FileShare object inserted into
 	 * the database.
 	 */
-	if (!(share = db_lookup_md5 (sdb, md5)))
+	if (!(share = db_lookup_md5 (sdb, md5, NULL)))
 	{
 		FT->DBGFN (FT, "%s: unable to lookup md5 %s",
 		           ft_node_fmt (sdb->node), md5_fmt (md5));
@@ -1827,14 +2049,19 @@
 {
 	DBC      *cursor;
 	u_int32_t flags;
-};
 
-static int cleanup_matches (DBT *data, void *udata)
-{
-	free (data->data);
-	free (data);
-	return TRUE;
-}
+	/* the token this is searching for */
+	uint32_t  token;
+	
+	/* where we should store the order after lookup */ 
+	uint8_t   *optr;
+
+	/* whether this is an exclude token */
+	BOOL       exclude;
+
+	/* duplicate count */
+	db_recno_t  len;
+};
 
 static int cleanup_cursors (struct cursor_stream *s, void *udata)
 {
@@ -1843,15 +2070,14 @@
 	return TRUE;
 }
 
-static void token_cleanup (List *matches, List *cursors)
+static void token_cleanup (List *cursors)
 {
-	list_foreach_remove (matches, (ListForeachFunc)cleanup_matches, NULL);
 	list_foreach_remove (cursors, (ListForeachFunc)cleanup_cursors, NULL);
 }
 
 static DBC *get_cursor (DB *dbp, uint32_t token)
 {
-	static struct tokenidx_key keyrec;
+	struct tokenidx_key keyrec;
 	DBC *dbcp;
 	DBT  key;
 	DBT  data;
@@ -1879,13 +2105,19 @@
 	return dbcp;
 }
 
-static List *token_gather_cursors (DB *dbp, uint32_t *tokens)
+static List *token_gather_cursors (DB *dbp, uint32_t *qtokens,
+				   uint32_t *etokens, uint8_t *ordmap)
 {
 	uint32_t *t;
 	List     *cursors = NULL;
 	DBC      *dbcp;
+	uint8_t  *ordptr;
 
-	for (t = tokens; t && *t; t++)
+	/* ignore queries with just exclude tokens */
+	if (!qtokens || !*qtokens)
+		return NULL;
+
+	for (t = qtokens, ordptr = ordmap; t && *t; t++, ordptr++)
 	{
 		struct cursor_stream *s;
 
@@ -1893,39 +2125,45 @@
 		 * abort the search (and return 0 results) */
 		if (!(dbcp = get_cursor (dbp, *t)))
 		{
-			token_cleanup (NULL, cursors);
+			token_cleanup (cursors);
 			return NULL;
 		}
 
 		if (!(s = malloc (sizeof (struct cursor_stream))))
 			continue;
 
-		s->cursor = dbcp;
-		s->flags  = DB_CURRENT;
+		s->cursor  = dbcp;
+		s->flags   = DB_CURRENT;
+		s->token   = *t;
+		s->optr    = ordmap ? ordptr : NULL;
+		s->exclude = FALSE;
 
 		cursors = list_prepend (cursors, s);
 	}
 
-	return cursors;
-}
+	for (t = etokens; t && *t; t++)
+	{
+		struct cursor_stream *s;
 
-static void token_add_result (List **results, DBT *data)
-{
-	DBT *copy;
+		/* skip any missing tokens: we didn't want them
+		 * anyway */
+		if (!(dbcp = get_cursor (dbp, *t)))
+			continue;
 
-	/* make a complete allocated copy and append to the list */
-	if (!(copy = MALLOC (sizeof (DBT))))
-		return;
+		if (!(s = malloc (sizeof (struct cursor_stream))))
+			continue;
 
-	copy->size = data->size;
+		s->cursor  = dbcp;
+		s->flags   = DB_CURRENT;
+		s->token   = *t;
+		s->optr    = NULL;
+		s->exclude = TRUE;
 
-	if (!(copy->data = gift_memdup (data->data, data->size)))
-	{
-		free (copy);
-		return;
+		cursors = list_prepend (cursors, s);
 	}
 
-	*results = list_prepend (*results, copy);
+
+	return cursors;
 }
 
 /*
@@ -1941,8 +2179,12 @@
 	assert (data->size == sizeof (*datarec));
 	datarec = data->data;
 
+#ifndef SEARCH_DB_BENCHMARK
 	if (datarec->sdb->node == NULL)
 		assert (remove_active == TRUE);
+#else
+	assert (datarec->sdb->node != NULL);
+#endif
 
 	/* if node is NULL, stale is TRUE */
 	return BOOL_EXPR (datarec->sdb->node == NULL);
@@ -1950,8 +2192,8 @@
 
 static BOOL look_for (struct cursor_stream *s, DBT *data_cmp)
 {
-	static struct tokenidx_data *datarec_cmp;
 	static struct tokenidx_data *datarec;
+	static struct tokenidx_data *datarec_cmp;
 	DBT key;
 	DBT data;
 	int cmp;
@@ -1967,7 +2209,7 @@
 	 * while attempting to locate any possible token intersection according
 	 * to the md5sum (compare cmp_data vs data).
 	 */
-	for (; (s->cursor)->c_get (s->cursor, &key, &data, s->flags) == 0;
+	for (; s->flags && (s->cursor)->c_get (s->cursor, &key, &data, s->flags) == 0;
 	     s->flags = DB_NEXT_DUP)
 	{
 		/* ignore nodes currently being removed */
@@ -1997,17 +2239,25 @@
 		/* matched, note that we will not reset flags as this exact position
 		 * will be passed by the parent cursor as well */
 		if (cmp == 0)
+		{
+			/* fill in the order while we have the
+			 * tokenidx_data record available */
+			if (s->optr)
+				(*s->optr) = ((struct tokenidx_data *)
+					      (data.data))->order;
+
 			return TRUE;
+		}
 	}
 
-	/* this set has exhausted, no more data left...we should really set
-	 * some special cursor flag so that we stop searching this stream. */
+	s->flags = 0;
+
+	/* this set has exhausted, no more data left */
 	return FALSE;
 }
 
-static void calc_shortest (struct cursor_stream *s, void **args)
+static void calc_length (struct cursor_stream *s, void *udata)
 {
-	db_recno_t *count = args[0];
 	db_recno_t  scnt;
 	int         ret;
 
@@ -2021,47 +2271,79 @@
 		return;
 	}
 
-	/*
-	 * This cursor's length is shorter than the last known cursor stream, so
-	 * we should reset the smallest length and current "located" stream
-	 * value on the args data.
-	 */
-	if (*count == 0 || scnt < *count)
-	{
-		*count = scnt;
-		args[1] = s;
-	}
+	s->len = scnt;
+}
+
+static int compare_length (struct cursor_stream *a, struct cursor_stream *b)
+{
+	if (a->len > b->len)
+		return 1;
+
+	if (a->len < b->len)
+		return -1;
+
+	return 0;
 }
 
 static struct cursor_stream *get_start_cursor (List **qt)
 {
 	struct cursor_stream *s;
 	List      *link;
-	void      *args[2];
-	db_recno_t count = 0;
-
-	args[0] = &count;
-	args[1] = NULL;
 
 	/*
 	 * Loop through all cursor streams in order to calculate the shortest
-	 * cursor (in terms of number of duplicates).  See below (match_qt) for an
+	 * cursor (in terms of number of duplicates).  See below (match_tokens) for an
 	 * explanation of why we do this.  Note that if we only have one
 	 * element in this list we can assume it is the shortest and skip the
 	 * cursor count retrieval.
 	 */
 	if (list_next (*qt))
-		list_foreach (*qt, (ListForeachFunc)calc_shortest, args);
+	{
+		List *ptr;
+		uint32_t last_token = 0;
+		
+		list_foreach (*qt, (ListForeachFunc)calc_length, NULL);
 
-	/*
-	 * If args[1] is non-NULL, we have located an appropriate node, remove from
-	 * the cursor list and return the beginning cursor stream.  If args[1]
-	 * is NULL, we should simply pop off the 0th element and return it.
-	 */
-	if (args[1])
-		link = list_find (*qt, args[1]);
+		/*
+		 * We sort separately rather than doing sorted inserts
+		 * so that we can avoid counting if some of the tokens
+		 * don't exist.
+		 */
+		*qt = list_sort (*qt, (CompareFunc)compare_length);
+
+		/* 
+		 * Verify that there are no duplicate tokens (which
+		 * will now be adjacent). Duplicates can occur only
+		 * when the same token appears in both the query and
+		 * exclude lists, as each list was uniq'd
+		 * individually.
+		 */
+		for (ptr = *qt; ptr; ptr = list_next (ptr))
+		{
+			s = ptr->data;
+			
+			if (s->token == last_token)
+				return NULL;
+			
+			last_token = s->token;
+		}
+
+		/* loop until we find a query token */
+		for (ptr = *qt; ptr; ptr = list_next (ptr))
+		{
+			s = ptr->data;
+
+			if (s->exclude == FALSE)
+				break;
+		}
+
+		link = ptr;
+	}
 	else
-		link = list_nth (*qt, 0);
+		link = *qt;
+
+	/* remove from the cursor list and return the beginning cursor
+	 * stream */
 
 	if (!link)
 		return NULL;
@@ -2069,12 +2351,67 @@
 	/* we need to assign this before we remove the link as it will be
 	 * freed by removal */
 	s = link->data;
+
 	*qt = list_remove_link (*qt, link);
 
 	return s;
 }
 
-static int match_qt (List **results, List **qt, int max_results)
+/*
+ * We keep a list of the ordering of tokens in the query. This is
+ * mapped to the actual values of the "order" fields in tokenidx_data
+ * for each token, which give the token numbers used when this result
+ * was added (and thus those used in the order list in
+ * sharedata_data). Simple string comparison is then used to check
+ * that each search result contains the mapped ordering(s) in the
+ * share data. The order list for each share is a temporary copy, so,
+ * after matching, we overwrite the matched orders with separators so
+ * they can only match once.
+ */
+static BOOL check_order (uint8_t *share_order, uint8_t *order, uint8_t *ordmap)
+{
+	uint8_t *newmap, *ptr, *sptr;
+	int ordlen, i;
+	BOOL ret = TRUE;
+
+	if (order == NULL ||
+	    share_order == NULL)
+		return TRUE;
+
+	ordlen = strlen (order);
+	
+	newmap = MALLOC (ordlen + 1);
+	
+	for (i = 0, ptr = newmap; i <= ordlen; i++)
+	{
+		if (order[i] > ORDER_SEP)
+			*(ptr++) = ordmap[order[i] - ORDER_MIN];
+		else
+		{
+			/* we have a full phrase to check */
+			*ptr = 0;
+			sptr = strstr (share_order, newmap);
+
+			if (sptr == NULL)
+			{			
+				ret = FALSE;
+				break;
+			}
+			
+			/* erase it so it won't match next time */
+			memset (sptr, ORDER_SEP, ptr-newmap);
+
+			ptr = newmap;
+		}
+	}
+
+	free (newmap);
+
+	return ret;
+}
+
+static int match_tokens (Array **results, List **qt, int max_results,
+		     uint8_t *order, uint8_t *ordmap)
 {
 	struct cursor_stream *s;
 	List      *ptr;
@@ -2115,6 +2452,9 @@
 
 		lost = FALSE;
 
+		if (s->optr)
+			(*s->optr) = ((struct tokenidx_data *)(data.data))->order;
+
 		/*
 		 * Walk along all the other tokens looking for an intersection.  Note
 		 * that this code holds the last position of the cursor so that we
@@ -2122,7 +2462,8 @@
 		 */
 		for (ptr = *qt; ptr; ptr = list_next (ptr))
 		{
-			if (!look_for (ptr->data, &data))
+			if (look_for (ptr->data, &data) ==
+			    ((struct cursor_stream *)(ptr->data))->exclude)
 			{
 				lost = TRUE;
 				break;
@@ -2135,11 +2476,36 @@
 		 */
 		if (lost == FALSE)
 		{
-			token_add_result (results, &data);
+			struct tokenidx_data *datarec = data.data;
+			uint8_t *share_order;
+			Share *share;
+			
+			/* grab the Share and order list */
+			if (!(share = db_lookup_md5 (datarec->sdb, datarec->md5,
+						     &share_order)))
+			{
+				FT->DBGFN (FT, "%s: unable to lookup md5 %s",
+					   ft_node_fmt (datarec->sdb->node),
+					   md5_fmt (datarec->md5));
+				continue;
+			}
 
-			/* make sure we cap the size of the results
-			 * TODO: this is a major bug here!  we cant cap the size of
-			 * the results until after we apply the exclusion set! */
+			/* do some more verification first */
+			if (order && check_order (share_order, order, ordmap) == FALSE)
+			{
+				ft_share_unref (share);
+				free (share_order);
+
+				continue;
+			}
+			
+			free (share_order);
+
+			/* and add it */
+			if (max_results)
+				array_push (results, share);
+
+			/* make sure we cap the size of the results */
 			matches++;
 
 			if (max_results && matches >= max_results)
@@ -2156,66 +2522,6 @@
 	return matches;
 }
 
-static int match_et (List **results, List **et, int max_results)
-{
-	if (!(*results) || !(*et))
-		return 0;
-
-	return 0;
-}
-
-static List *token_lookup_match (List *qt, List *et, int max_results)
-{
-	List *results = NULL;
-
-	match_qt (&results, &qt, max_results);
-	match_et (&results, &et, max_results);
-
-	token_cleanup (NULL, qt);
-	token_cleanup (NULL, et);
-
-	return results;
-}
-
-static int lookup_ret (DBT *dbt, void **args)
-{
-	Array **a           = args[0];
-	int    *max_results = args[1];
-	int    *matches     = args[2];
-	static struct tokenidx_data *datarec;
-
-	/* do not process more results than we were allowed */
-	if (*max_results && *matches >= *max_results)
-		return TRUE;
-
-	assert (dbt->size == sizeof (struct tokenidx_data));
-	datarec = dbt->data;
-
-	/*
-	 * WARNING/TODO: We do not match realm here, and we REALLY NEED TO.
-	 * Realm matches need to use a partial database lookup before the result
-	 * is fully selected and added to the list.
-	 */
-	if (add_search_result (a, datarec->sdb, datarec->md5))
-		(*matches)++;
-
-	cleanup_matches (dbt, NULL);
-
-	return TRUE;
-}
-
-static int token_lookup_ret (Array **a, List *cursors, char *realm,
-                             int max_results)
-{
-	int nmatches = 0;
-	void *args[] = { a, &max_results, &nmatches, realm };
-
-	cursors = list_foreach_remove (cursors, (ListForeachFunc)lookup_ret, args);
-	list_free (cursors);
-
-	return nmatches;
-}
-
 /*
  * Perform a search through the query and exclude token sets.  This adds a
  * huge level of complexity to the search algorithm, and uses a specialized
@@ -2231,42 +2537,35 @@
  */
 static int db_search_tokens (Array **a, char *realm,
                              uint32_t *query, uint32_t *exclude,
-                             int max_results)
+			     uint8_t *order, int max_results)
 {
 	DB   *dbp;
-    List *qt_cursors = NULL;
-	List *et_cursors = NULL;
 	List *cursors = NULL;
 	int   results = 0;
+	uint8_t *ordmap = NULL;
 
 	if (!(dbp = db_tokenidx()))
 		return 0;
 
+	/* map the tokens list to their ordering in the original
+	 * record */
+	if (order)
+	{
+		int len = get_tokens_len (query);
+
+		ordmap = CALLOC (len, 1);
+	}
+
 	/* construct a list of all positioned cursors, effectively retrieving a
 	 * list of token result streams */
-	qt_cursors = token_gather_cursors (dbp, query);
-	et_cursors = token_gather_cursors (dbp, exclude);
+	cursors = token_gather_cursors (dbp, query, exclude, ordmap);
 
-	/*
-	 * Find the list of cursors which successfully matched this query by
-	 * first identifying the intersection of all cursors within qt_cursors,
-	 * and then excluding all matches from et_cursor.  Returns a newly
-	 * allocated list containing all share host ip addresses and MD5s that
-	 * matched the search.
-	 *
-	 * NOTE:
-	 * The cursors list result is not in the same "format" as qt_cursors,
-	 * the data held within is completely different.
-	 */
-	cursors = token_lookup_match (qt_cursors, et_cursors, max_results);
+	results = match_tokens (a, &cursors, max_results,
+				      order, ordmap);
 
-	/*
-	 * Add all results to the main result list, after unserialization
-	 * occurs.  This logic also handles cleanup of all non-returned data
-	 * held within the cursors list.
-	 */
-	if (cursors)
-		results = token_lookup_ret (a, cursors, realm, max_results);
+	token_cleanup (cursors);
+	
+	free (ordmap);
 
 	return results;
 }
@@ -2315,6 +2614,8 @@
 		env_search_path = NULL;
 	}
 #endif /* USE_LIBDB */
+
+	db_initialized = FALSE;
 }
 
 /*****************************************************************************/
@@ -2360,6 +2661,11 @@
 	{
 		FT_SEARCH_DB(node)->shares--;
 		FT_SEARCH_DB(node)->size -= ((float)size / 1024.0) / 1024.0;
+		FT->DBGFN (FT, "%s: removed '%s' (%d, %d left)", ft_node_fmt(node), md5_fmt(md5), size, FT_SEARCH_DB(node)->shares);
+	}
+	else
+	{
+		FT->DBGFN (FT, "%s: '%s' removal failed", ft_node_fmt(node), md5_fmt(md5));
 	}
 #endif /* USE_LIBDB */
 
@@ -2383,6 +2689,11 @@
 	if (!sdb)
 		return TRUE;
 
+#ifndef SEARCH_DB_BENCHMARK
+	if (openft->shutdown)
+		return TRUE;
+#endif
+
 	/*
 	 * Schedule the removal and leave.  We cannot block for the entire
 	 * duration of this operation, but we can disassociate the FTSearchDB
@@ -2468,7 +2779,7 @@
 		return NULL;
 
 #ifdef USE_LIBDB
-	ret = db_lookup_md5 (FT_SEARCH_DB(node), md5);
+	ret = db_lookup_md5 (FT_SEARCH_DB(node), md5, NULL);
 #endif /* USE_LIBDB */
 
 	return ret;
@@ -2490,7 +2801,7 @@
 
 int ft_search_db_tokens (Array **a, char *realm,
                          uint32_t *query, uint32_t *exclude,
-                         int max_results)
+			 uint8_t *order, int max_results)
 {
 	int results = 0;
 
@@ -2498,7 +2809,7 @@
 		return results;
 
 #ifdef USE_LIBDB
-	results = db_search_tokens (a, realm, query, exclude, max_results);
+	results = db_search_tokens (a, realm, query, exclude, order, max_results);
 #endif /* USE_LIBDB */
 
 	return results;
@@ -2540,8 +2851,8 @@
 static int nodes = 0;
 static int files = 0;
 
-static int minnodes = 100;
-static int maxnodes = 500;
+static int minnodes = 150;
+static int maxnodes = 150;
 
 static int minqueries =  5000;
 static int maxqueries = 10000;
@@ -2603,10 +2914,16 @@
 		Share         *record;
 		unsigned char *md5 = key.data;
 
-		record = unserialize_record (FT_SEARCH_DB(node), md5, data.data);
+		record = unserialize_record (FT_SEARCH_DB(node), md5, data.data, NULL);
 		assert (record != NULL);
 
 		array_push (files, record);
+
+#if 0
+		/* make some duplicates for good measure */
+		if (rand() > RAND_MAX/100)
+			array_push (files, record);
+#endif
 		nfiles++;
 	}
 
@@ -2641,7 +2958,7 @@
 	}
 
 	nodes = stats->bt_ndata;
-	FT->dbg (FT, "%s: contains %d nodes\n", dbfile, nodes);
+	FT->dbg (FT, "%s: contains %d nodes", dbfile, nodes);
 
 	if (nodes > maxnodes)
 		nodes = maxnodes;
@@ -2718,7 +3035,7 @@
 
 		bm_close_db (hostdb);
 
-		if (i > maxnodes)
+		if (i >= maxnodes)
 			break;
 	}
 
@@ -2772,6 +3089,39 @@
 	return n;
 }
 
+static void free_queries (void)
+{
+	char *query;
+
+	while ((query = array_shift (&queries)))
+	{
+		free (query);
+	}
+
+	array_unset (&queries);
+}
+
+static void free_test_data (void)
+{
+	int i;
+	for (i = 0; i < nodes; i++)
+	{
+		FTNode *node = nodelist[i].node;
+		Array *files = nodelist[i].files;
+		Share *record;
+
+		while ((record = array_shift (&files)))
+			ft_share_unref (record);
+
+		array_unset (&files);
+
+		ft_node_free (node);
+	}
+	 
+	free (nodelist);
+}
+
+
 static double run_insert (void)
 {
 	StopWatch *gsw;
@@ -2794,6 +3144,10 @@
 			Share *share = array_index (&hl->files, j);
 			assert (share != NULL);
 
+#if 0
+			FT->dbg (FT, "inserting file %s",
+				 md5_fmt (share_get_hash (share,"MD5")->data));
+#endif
 			if (!(ft_search_db_insert (hl->node, share)))
 			{
 				FT->err (FT, "%s(%s): error inserting file",
@@ -2821,25 +3175,56 @@
 	gsw = stopwatch_new (TRUE);
 	assert (gsw != NULL);
 
+#ifndef INTERACTIVE
 	for (i = 0; i < nqueries; i++)
 	{
 		char *query = array_index (&queries, i);
+		char *exclude = "";
+#else
+	char query[100];
+	char exclude[100];
+
+	db_sync (NULL);
+
+	/* fixed size buffers *and* gets()?! 
+	 * hey, this is only for testing... */
+	while (gets (query))
+	{
+		StopWatch *sw;
+
+#endif
 		uint32_t *qtokens;
-		uint32_t etokens = 0;
+		uint32_t *etokens;
+		uint8_t *order;
 		Array *matches = NULL;
 		int hits;
 		int j;
-
-		qtokens = ft_search_tokenize (query);
+		
+#ifdef INTERACTIVE
+		gets (exclude);
+		sw = stopwatch_new (TRUE);
+#endif
+		qtokens = ft_tokenize_query (query, &order);
 		assert (qtokens != NULL);
+		etokens = ft_tokenize_query (exclude, NULL);
 
-		hits = ft_search_db_tokens (&matches, NULL, qtokens, &etokens, 100000);
+		hits = ft_search_db_tokens (&matches, NULL, qtokens, etokens,
+					    order, 100000);
 		free (qtokens);
+		free (etokens);
+		free (order);
 
+#ifdef INTERACTIVE
+		printf("'%s' (-'%s'): %d hits, %.06f elapsed\n", query, exclude, hits, stopwatch_free_elapsed (sw));
+#endif
 		for (j = 0; j < hits; j++)
 		{
 			Share *share = array_index (&matches, j);
-			share_unref (share);
+#ifdef INTERACTIVE
+			if (hits < 30)
+				printf ("%s\n", share->path);
+#endif
+			ft_share_unref (share);
 		}
 
 		array_unset (&matches);
@@ -2850,7 +3235,7 @@
 	return stime;
 }
 
-static double run_remove (void)
+static double run_remove (BOOL remove_singly)
 {
 	StopWatch *gsw;
 	double rtime;
@@ -2868,20 +3253,77 @@
 		assert (sw != NULL);
 #endif
 
-		if (!(ft_search_db_remove_host (node)))
+		if (remove_singly)
 		{
-			FT->err (FT, "error removing node %s", ft_node_fmt (node));
-			abort ();
+			int j;
+			Array *f=nodelist[i].files;
+			int flen=array_count(&f);
+
+			ft_search_db_open (node);
+
+			for(j=0;j<flen/2;j++) {
+				Share *file=array_splice (&f, j, 0, NULL);
+				Hash *hash=share_get_hash (file, "MD5");
+				if (hash) {
+					FT->dbg (FT,"removing file %s (%s)", file->path, ft_node_fmt(node));
+
+					if (!ft_search_db_remove(node,hash->data))
+						FT->err (FT,"error removing file %s (%s)", file->path, ft_node_fmt(node));
+				} else 
+					FT->err (FT, "error reading file array");
+			}
+			
+			ft_search_db_close (node, FALSE);
+
+			{
+				DB_BTREE_STAT *stats;
+				DB *db=FT_SEARCH_DB(node)->share_idx;
+				if (db)
+				{
+					if (!db->stat(db, &stats, 0))
+						assert (stats->bt_ndata == 0);
+					else
+					{
+						FT->err(FT, "failed to get sdb stats");
+						abort ();
+					}
+				}
+			}
+		}
+
+		if (1)
+		{
+			if (!(ft_search_db_remove_host (node)))
+			{
+				FT->err (FT, "error removing node %s", ft_node_fmt (node));
+				abort ();
+			}
 		}
 
 #if 0
 		FT->dbg (FT, "delete %s(%lu): %.06fs elapsed", ft_node_fmt (node),
 				 shares, stopwatch_free_elapsed (sw));
 #endif
-
 		ft_search_db_sync (node);
 	}
 
+	{
+		DB_BTREE_STAT *stats;
+		DB *db=db_tokenidx();
+		assert (db);
+
+		if (!db->stat(db, &stats, 0))
+		{
+			FT->dbg (FT, "tokenidx: %d key, %d data", stats->bt_nkeys, stats->bt_ndata);
+			assert (stats->bt_ndata == 0);
+		}
+		else
+		{
+			FT->err(FT, "failed to get sdb stats");
+			abort ();
+		}
+	}
+	
 	rtime = stopwatch_free_elapsed (gsw);
 
 	return rtime;
@@ -2903,13 +3345,20 @@
 	         nqueries, stime, (float)nqueries / stime);
 
 	/* remove */
-	rtime = run_remove ();
+	rtime = run_remove (FALSE);
 	FT->dbg (FT, "remove(%lu): %.06fs elapsed (avg %.02f files/s)",
 	         files, rtime, (float)files / rtime);
+
+	db_sync (NULL);
 }
 
 BOOL test_suite_search_db (Protocol *p)
 {
+#ifndef SEARCH_DB_BENCHMARK
+	FT->err (FT, "benchmarking requested but disabled");
+	return FALSE;
+
+#else
 	int ret;
 
 	if ((ret = load_test_data ("test.data")) <= 0)
@@ -2924,10 +3373,14 @@
 		return FALSE;
 	}
 
-	ft_search_db_init ("benchtemp", 209715200);
+	ft_search_db_init ("benchtemp", 20971520);
 	test_benchmarks ();
 
+	free_test_data ();
+	free_queries ();
+
 	return TRUE;
+#endif
 }
 
 #endif /* OPENFT_TEST_SUITE */
Index: ft_search_db.h
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_search_db.h,v
retrieving revision 1.21
diff -u -r1.21 ft_search_db.h
--- ft_search_db.h	26 Oct 2003 13:15:43 -0000	1.21
+++ ft_search_db.h	13 Jun 2004 23:15:57 -0000
@@ -111,6 +111,7 @@
 
 	unsigned long shares;              /**< total files currently shared */
 	double        size;                /**< total size (MB) */
+	Array   *dups;                     /* duplicated hashes */
 } FTSearchDB;
 
 /* shorthand */
@@ -239,7 +240,7 @@
  * queried and the search is much more complex and expensive.
  */
 int ft_search_db_tokens (Array **a, char *realm, uint32_t *query,
-						 uint32_t *exclude, int max_results);
+			 uint32_t *exclude, uint8_t *order, int max_results);
 
 /*****************************************************************************/
 
Index: ft_search_exec.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_search_exec.c,v
retrieving revision 1.58
diff -u -r1.58 ft_search_exec.c
--- ft_search_exec.c	7 Jan 2004 12:06:42 -0000	1.58
+++ ft_search_exec.c	13 Jun 2004 23:15:58 -0000
@@ -35,22 +35,7 @@
 
 #include "ft_search_exec.h"
 
-/*****************************************************************************/
-
-/*
- * Defines a special set of characters which will be skipped when tokenizing
- * each individual word.  For example, "foo!bar" would produce the same
- * token as "foobar".
- */
-#define SEARCH_TOKEN_PUNCT ",`'!?*"
-
-/*
- * Defines the set of characters which will be used a delimiters between
- * individual token words.  In addition to this set, numbers are treated
- * as special delimiters through a second string scan.  For example,
- * "s03e21" will produce the token word "s03e21", "3", and "21".
- */
-#define SEARCH_TOKEN_DELIM "\\/ _-.[]()\t"
+#include "ft_tokenize.h"
 
 /*****************************************************************************/
 
@@ -58,7 +43,7 @@
  * Enable if you wish debugging information regarding the elapsed search time
  * to be displayed.
  */
-/* #define SEARCH_TIMING */
+/*#define SEARCH_TIMING*/
 
 /*****************************************************************************/
 
@@ -93,6 +78,7 @@
 	char             *f_exclude;       /* exclude string */
 	uint32_t         *f_qtokens;       /* query tokens list */
 	uint32_t         *f_etokens;       /* exclude tokens list */
+	uint8_t          *f_order;
 	char             *f_realm;         /* optional realm to filter by */
 
 	/**
@@ -201,268 +187,6 @@
 
 /*****************************************************************************/
 
-static BOOL is_token_punct (int c)
-{
-	const char *ptr;
-
-	/* TODO: Lots of room for optimization here */
-	for (ptr = SEARCH_TOKEN_PUNCT; *ptr != '\0'; ptr++)
-	{
-		if (*ptr == c)
-			return TRUE;
-	}
-
-	return FALSE;
-}
-
-static int next_letter (const char **strref, size_t *lenref)
-{
-	const char *str = *strref;
-	size_t len = *lenref;
-	int c;
-
-	if (len == 0)
-		return 0;
-
-	/* skip any punctuation characters while scanning the word so that we
-	 * don't need to actually modify the word */
-	while (is_token_punct (*str) == TRUE)
-	{
-		if (len == 1)
-			return 0;
-
-		str++;
-		len--;
-	}
-
-	c = tolower (*str);
-	assert (c != '\0');
-
-	*strref = str + 1;
-	*lenref = len - 1;
-
-	return c;
-}
-
-/*
- * I believe this came from an old version of GLib or something.  Verify
- * later and add the appropriate credit.
- */
-static uint32_t make_token (const char *word, size_t len)
-{
-	uint32_t hash = 0;
-	int letter;
-
-	if (word == NULL)
-		return 0;
-
-	if ((letter = next_letter (&word, &len)) == 0)
-		return 0;
-
-	hash = letter;
-
-	while ((letter = next_letter (&word, &len)) != 0)
-		hash = (hash << 5) - hash + letter;
-
-	return hash;
-}
-
-/*****************************************************************************/
-
-struct token_list
-{
-	uint32_t *tokens;
-	size_t    nmemb;
-	size_t    size;
-};
-
-static void tlist_init (struct token_list *tlist)
-{
-	tlist->tokens = NULL;
-	tlist->nmemb = 0;
-	tlist->size = 0;
-}
-
-static BOOL tlist_resize_min (struct token_list *tlist, size_t nmemb)
-{
-	uint32_t *newalloc;
-	size_t size;
-
-	if (tlist->size >= nmemb)
-		return TRUE;
-
-	if ((size = tlist->size) == 0)
-		size = 1;
-
-	while (size < nmemb)
-		size *= 2;
-
-	if (!(newalloc = realloc (tlist->tokens, size * sizeof (uint32_t))))
-		return FALSE;
-
-	tlist->tokens = newalloc;
-	tlist->size = size;
-
-	return TRUE;
-}
-
-static BOOL tlist_add (struct token_list *tlist, uint32_t token)
-{
-	if (tlist_resize_min (tlist, tlist->nmemb + 1) == FALSE)
-		return FALSE;
-
-	tlist->tokens[tlist->nmemb++] = token;
-
-	return TRUE;
-}
-
-static BOOL tlist_addword (struct token_list *tlist,
-                           const char *word, size_t wordlen)
-{
-	uint32_t token;
-
-	if ((token = make_token (word, wordlen)) > 0)
-		return tlist_add (tlist, token);
-
-	return FALSE;
-}
-
-static void add_numbers (struct token_list *tlist, const char *str)
-{
-	char *ptr;
-	size_t numlen;
-
-	/* implicitly scan past leading 0's as they are found only for padding,
-	 * not to represent octal numbers */
-	while ((ptr = strpbrk (str, "123456789")))
-	{
-		numlen = strspn (ptr, "0123456789");
-		assert (numlen > 0);
-
-		tlist_addword (tlist, ptr, numlen);
-
-		str = ptr + numlen;
-	}
-}
-
-static void add_words (struct token_list *tlist, const char *str)
-{
-	size_t wordlen;
-
-	while (1)
-	{
-		if ((wordlen = strcspn (str, SEARCH_TOKEN_DELIM)) > 0)
-			tlist_addword (tlist, str, wordlen);
-
-		if (str[wordlen] == '\0')
-			break;
-
-		str += wordlen + 1;
-	}
-}
-
-static void tlist_addstr (struct token_list *tlist, const char *str)
-{
-	/* lets us be lazy in the usage */
-	if (str == NULL)
-		return;
-
-	add_numbers (tlist, str);
-	add_words (tlist, str);
-}
-
-static int token_cmp (const void *a, const void *b)
-{
-	return INTCMP (*(uint32_t *)a, *(uint32_t *)b);
-}
-
-static void sort_and_uniq (struct token_list *tlist)
-{
-	size_t i;
-	size_t nmemb = 0;
-	uint32_t lasttoken = 0;
-
-	if (tlist->nmemb == 0)
-		return;
-
-	/* sort */
-	qsort (tlist->tokens, tlist->nmemb, sizeof (uint32_t), token_cmp);
-
-	/* ... and uniq */
-	for (i = 0; i < tlist->nmemb; i++)
-	{
-		if (lasttoken > 0)
-		{
-			/* skip duplicates */
-			if (tlist->tokens[i] == lasttoken)
-				continue;
-		}
-
-		lasttoken = tlist->tokens[i];
-		assert (lasttoken != 0);
-
-		/*
-		 * Only update the token list position if we have actually detected a
-		 * duplicate and the number of elements in the new list will differ
-		 * from the old list.
-		 */
-		if (nmemb != i)
-			tlist->tokens[nmemb] = lasttoken;
-
-		nmemb++;
-	}
-
-	tlist->nmemb = nmemb;
-}
-
-static uint32_t *tlist_finish (struct token_list *tlist)
-{
-	/* sort the token list, then remove duplicates (by way of rewinding the
-	 * stream) */
-	sort_and_uniq (tlist);
-
-	/* add the sentinel (token=0) */
-	tlist_add (tlist, 0);
-
-	return tlist->tokens;
-}
-
-/*****************************************************************************/
-
-uint32_t *ft_search_tokenize (const char *string)
-{
-	struct token_list tlist;
-
-	if (string == NULL)
-		return NULL;
-
-	tlist_init (&tlist);
-	tlist_addstr (&tlist, string);
-
-	return tlist_finish (&tlist);
-}
-
-uint32_t *ft_search_tokenizef (Share *file)
-{
-	struct token_list tlist;
-
-	if (file == NULL)
-		return NULL;
-
-	tlist_init (&tlist);
-
-	tlist_addstr (&tlist, SHARE_DATA(file)->path);
-	tlist_addstr (&tlist, share_get_meta (file, "tracknumber"));
-	tlist_addstr (&tlist, share_get_meta (file, "artist"));
-	tlist_addstr (&tlist, share_get_meta (file, "album"));
-	tlist_addstr (&tlist, share_get_meta (file, "title"));
-	tlist_addstr (&tlist, share_get_meta (file, "genre"));
-
-	return tlist_finish (&tlist);
-}
-
-/*****************************************************************************/
-
 static int fill_sdata (SearchData *sdata, int nmax,
                        FTSearchResultFn resultfn, void *udata,
                        ft_search_flags_t type, const char *realm,
@@ -484,6 +208,7 @@
 		{
 			uint32_t *qtokens;
 			uint32_t *etokens;
+			uint8_t *order;
 
 			/* hidden searches are pretokenized */
 			if (sdata->type & FT_SEARCH_HIDDEN)
@@ -493,13 +218,14 @@
 
 				query   = NULL;
 				exclude = NULL;
+				order = NULL;
 			}
 			else
 			{
-				if (!(qtokens = ft_search_tokenize (query)))
+				if (!(qtokens = ft_tokenize_query (query, &order)))
 					return FALSE;
 
-				etokens = ft_search_tokenize (exclude);
+				etokens = ft_tokenize_query (exclude, NULL);
 			}
 
 			sdata->sfunc     = (FTSearchFunc)cmp_filename;
@@ -507,6 +233,7 @@
 			sdata->f_exclude = exclude;
 			sdata->f_qtokens = qtokens;
 			sdata->f_etokens = etokens;
+			sdata->f_order   = order;
 			sdata->f_realm   = (char *)realm;
 		}
 		break;
@@ -550,6 +277,7 @@
 		{
 			free (sdata->f_qtokens);
 			free (sdata->f_etokens);
+			free (sdata->f_order);
 		}
 	}
 	else if (FT_SEARCH_METHOD(sdata->type) == FT_SEARCH_MD5)
@@ -634,7 +362,7 @@
 	 case FT_SEARCH_FILENAME:
 		hits = ft_search_db_tokens (&matches, sdata->f_realm,
 		                            sdata->f_qtokens, sdata->f_etokens,
-		                            max_hits);
+					    sdata->f_order, max_hits);
 		break;
 	 default:
 		abort ();                      /* shouldnt happen */
Index: ft_search_obj.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_search_obj.c,v
retrieving revision 1.16
diff -u -r1.16 ft_search_obj.c
--- ft_search_obj.c	15 Nov 2003 12:15:58 -0000	1.16
+++ ft_search_obj.c	13 Jun 2004 23:15:59 -0000
@@ -20,6 +20,7 @@
 #include "ft_search_exec.h"
 
 #include "ft_search_obj.h"
+#include "ft_tokenize.h"
 
 /*****************************************************************************/
 
@@ -42,8 +43,8 @@
 	dst->realm   = STRDUP (realm);
 	dst->query   = STRDUP (query);
 	dst->exclude = STRDUP (exclude);
-	dst->qtokens = ft_search_tokenize (query);
-	dst->etokens = ft_search_tokenize (exclude);
+	dst->qtokens = ft_tokenize_query (query, &dst->order);
+	dst->etokens = ft_tokenize_query (exclude, NULL);
 }
 
 static int search_timeout (FTSearch *srch)
@@ -88,6 +89,7 @@
 	free (params->exclude);
 	free (params->qtokens);
 	free (params->etokens);
+	free (params->order);
 }
 
 static void search_free (FTSearch *srch)
Index: ft_search_obj.h
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_search_obj.h,v
retrieving revision 1.8
diff -u -r1.8 ft_search_obj.h
--- ft_search_obj.h	2 Nov 2003 12:09:06 -0000	1.8
+++ ft_search_obj.h	13 Jun 2004 23:15:59 -0000
@@ -44,6 +44,11 @@
  */
 /* #define FT_SEARCH_PARANOID */
 
+/*
+ * Get results directly from their source supernode instead of having them forwarded
+ */
+#define FT_SEARCH_DIRECT
+
 /*****************************************************************************/
 
 /**
@@ -69,7 +74,13 @@
 	 * ::ft_search_tokenize output.  This is not cryptographically secure and
 	 * is only expected to appease the casual privacy nut, sorry.
 	 */
-	FT_SEARCH_HIDDEN   = 0x20
+	FT_SEARCH_HIDDEN   = 0x20,
+
+	/**
+	 * Request only a the number of results, not the results themselves.
+	 */
+	FT_SEARCH_COUNT    = 0x40,
+
 } ft_search_flags_t;
 
 /* take only the bits that determine what type of search it is */
@@ -90,6 +101,8 @@
 
 	uint32_t         *qtokens;         /**< Query tokens */
 	uint32_t         *etokens;         /**< Exclude tokens */
+
+	uint8_t          *order;           /**< Order of quoted phrases */
 } ft_search_parms_t;
 
 /**
Index: ft_session.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_session.c,v
retrieving revision 1.89
diff -u -r1.89 ft_session.c
--- ft_session.c	23 Dec 2003 21:29:39 -0000	1.89
+++ ft_session.c	13 Jun 2004 23:16:00 -0000
@@ -432,7 +432,7 @@
 		if (need_search)
 		{
 			ft_packet_put_uint16 (pkt, (uint16_t)FT_NODE_SEARCH, TRUE);
-			ft_packet_put_uint16 (pkt, 10, TRUE);
+			ft_packet_put_uint16 (pkt, 15, TRUE);
 		}
 
 		if (need_index)
@@ -584,13 +584,17 @@
 	if (FT_CONN(node))
 	{
 		assert (FT_CONN(node)->fd >= 0);
+		FT->DBGFN (FT, "%s: already connected", ft_node_fmt (node));
 
 		ft_session_add_purpose (node, goal);
 		return -1;
 	}
 
 	if (ft_node_fw (node) || !ft_conn_auth (node, TRUE))
+	{
+		FT->DBGFN (FT, "%s: fw/unauth", ft_node_fmt (node));
 		return -1;
+	}
 
 	FT->DBGFN (FT, "attempting connection to %s", ft_node_fmt (node));
 
@@ -648,6 +652,8 @@
 	FTNode     *node;
 	FTSession  *session;
 
+	openft->ninfo.indirect = 0;
+
 	if (!(c = tcp_accept (listen, FALSE)))
 	{
 		FT->err (FT, "accept: %s", GIFT_NETERROR());
Index: ft_share_file.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_share_file.c,v
retrieving revision 1.21
diff -u -r1.21 ft_share_file.c
--- ft_share_file.c	2 Nov 2003 12:09:07 -0000	1.21
+++ ft_share_file.c	13 Jun 2004 23:16:00 -0000
@@ -21,6 +21,7 @@
 #include "ft_search.h"
 #include "ft_search_exec.h"
 #include "ft_share_file.h"
+#include "ft_tokenize.h"
 
 /*****************************************************************************/
 
@@ -40,7 +41,7 @@
 
 	share->node = node;
 	share->ninfo = ninfo;
-	share->tokens = ft_search_tokenizef (file);
+	share->tokens = ft_tokenize_share (file, &share->order);
 
 	return share;
 }
@@ -51,7 +52,7 @@
 	Share   *file;
 	FTShare *share;
 
-	if (!(file = share_new_ex (FT, NULL, 0, filename, mime, size, 0)))
+	if (!(file = share_new_ex (FT, filename, mime, size, 0)))
 		return NULL;
 
 	if (!share_set_hash (file, "MD5", md5, 16, TRUE))
@@ -88,6 +89,7 @@
 		return;
 
 	free (share->tokens);
+	free (share->order);
 	free (share);
 }
 
@@ -138,7 +140,7 @@
 
 	/* tokenize this query for fast searching */
 	if (!share->tokens)
-		share->tokens = ft_search_tokenizef (file);
+		share->tokens = ft_tokenize_share (file, &share->order);
 
 	if (!share->tokens)
 		return FALSE;
Index: ft_share_file.h
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/ft_share_file.h,v
retrieving revision 1.14
diff -u -r1.14 ft_share_file.h
--- ft_share_file.h	2 Nov 2003 12:09:07 -0000	1.14
+++ ft_share_file.h	13 Jun 2004 23:16:00 -0000
@@ -47,6 +47,7 @@
 	                                    *   search results */
 	uint32_t           *tokens;        /**< List of searchable tokens for
 	                                    *   for this file */
+	uint8_t            *order;         /**< Order of tokens */
 } FTShare;
 
 /*****************************************************************************/
Index: proto/ft_handshake.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/proto/ft_handshake.c,v
retrieving revision 1.26
diff -u -r1.26 ft_handshake.c
--- proto/ft_handshake.c	9 May 2004 00:14:53 -0000	1.26
+++ proto/ft_handshake.c	13 Jun 2004 23:16:00 -0000
@@ -348,15 +348,15 @@
 {
 	int n;
 
-	n = ft_netorg_foreach (FT_NODE_SEARCH | FT_NODE_INDEX, FT_NODE_CONNECTED, 15,
-	                       FT_NETORG_FOREACH(nodelist_add), args);
+	n = ft_netorg_random (FT_NODE_SEARCH | FT_NODE_INDEX, 0, 15,
+	                      FT_NETORG_FOREACH(nodelist_add), args);
 
 	/* we weren't able to come up with enough search/index nodes, try to give
 	 * them at least something */
 	if (n < 10)
 	{
-		n += ft_netorg_foreach (FT_NODE_USER, FT_NODE_CONNECTED, 20,
-		                        FT_NETORG_FOREACH(nodelist_add), args);
+		n += ft_netorg_random (FT_NODE_USER, 0, 20,
+		                       FT_NETORG_FOREACH(nodelist_add), args);
 	}
 
 	return n;
@@ -381,8 +381,8 @@
 		/* otherwise we should respond only to the connected classes that
 		 * they requested (this is used to graph the network through third
 		 * party tools) */
-		nodes = ft_netorg_foreach (klass, FT_NODE_CONNECTED, nreq,
-		                           FT_NETORG_FOREACH(nodelist_add), &args);
+		nodes = ft_netorg_random (klass, 0, nreq,
+		                          FT_NETORG_FOREACH(nodelist_add), &args);
 	}
 
 	/* we're done w/ this :) */
@@ -493,6 +493,8 @@
 		ft_node_set_class (node, klass);
 #endif
 
+		//		FT->DBGSOCK (FT, c, "got %s (%s) indirect=%d", ft_node_fmt (node), ft_node_classstr_full (node->ninfo.klass), node->ninfo.indirect);
+		
 		if (conns + newconns > conns_max)
 			continue;
 
@@ -513,7 +515,7 @@
 		}
 	}
 
-#if 0
+#if 1
 	FT->DBGSOCK (FT, c, "rcvd %i nodes (%i new conns)", n, newconns);
 #endif
 
Index: proto/ft_query.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/proto/ft_query.c,v
retrieving revision 1.15
diff -u -r1.15 ft_query.c
--- proto/ft_query.c	21 Nov 2003 16:05:18 -0000	1.15
+++ proto/ft_query.c	13 Jun 2004 23:16:00 -0000
@@ -546,7 +546,7 @@
 }
 
 static BOOL create_result (TCPC *c, FTPacket *packet, int browse,
-                           Share *share, ft_nodeinfo_t *owner,
+                           Share *share, ft_nodeinfo_t *parent, ft_nodeinfo_t *owner,
                            unsigned int *retavail)
 {
 	uint32_t       host;
@@ -585,7 +585,12 @@
 	/* if host is 0, assume that these are local shares from that node */
 	if (host == 0)
 	{
+		FT->DBGSOCK (FT, c, "alias '%s', hash %s, parent %s", alias, md5_fmt (md5), net_ip_str (parent->host));
+#if 0
 		if ((host = FT_NODE_INFO(c)->host) == 0)
+#else
+		if ((host = parent->host) == 0)
+#endif
 		{
 			FT->DBGSOCK (FT, c, "invalid remote node registration");
 			return FALSE;
@@ -782,7 +787,10 @@
 
 	/* execute a search on our local node before forwarding begins */
 	if ((results = exec_search (c, &params)) < 0)
+	{
+		FT->DBGSOCK (FT, c, "%s: search error", ft_guid_fmt (params.guid));
 		return;
+	}
 
 	/* forward the search along to our peers if it still has time-to-live */
 	if ((peers = forward_search (c, &params, params.nmax - results)) > 0)
@@ -869,7 +877,7 @@
 	if (!(parent = get_parent_info (FT_NODE(c), pkt)))
 		return;
 
-	if (!(create_result (c, pkt, FALSE, &share, &owner, &avail)))
+	if (!(create_result (c, pkt, FALSE, &share, parent, &owner, &avail)))
 		return;
 
 	ft_search_reply (srch, &owner, parent, &share, avail);
@@ -1101,7 +1109,7 @@
 
 	if (ft_packet_length (packet) > FT_GUID_SIZE)
 	{
-		if (!(create_result (c, packet, TRUE, &share, &owner, &avail)))
+		if (!(create_result (c, packet, TRUE, &share, NULL, &owner, &avail)))
 			return;
 
 		ft_browse_reply (browse, &owner, &share, avail);
Index: proto/ft_sharing.c
===================================================================
RCS file: /cvsroot/gift/OpenFT/src/proto/ft_sharing.c,v
retrieving revision 1.15
diff -u -r1.15 ft_sharing.c
--- proto/ft_sharing.c	23 Dec 2003 18:32:45 -0000	1.15
+++ proto/ft_sharing.c	13 Jun 2004 23:16:00 -0000
@@ -48,6 +48,12 @@
 	if (node->session->search_db)
 		return FALSE;
 
+	if (node->version < OPENFT_0_2_0_1)
+	{
+		FT->DBGSOCK (FT, FT_CONN(node), "refusing old would-be child");
+		return FALSE;
+	}
+
 	/*
 	 * NOTE: This is _NOT_ handled gracefully by the network and
 	 * absolutely needs to be!  This cannot be left like this.  The round
