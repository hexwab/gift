/*
 * $Id: gt_query_route.c,v 1.26 2003/06/06 04:06:32 jasta Exp $
 *
 * Copyright (C) 2001-2003 giFT project (gift.sourceforge.net)
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */

#include "gt_gnutella.h"

#include "gt_query_route.h"

#include "gt_packet.h"
#include "gt_protocol.h"

#include "gt_node.h"
#include "gt_utils.h"

#include "lib/stopwatch.h"

#ifdef USE_ZLIB
#include <zlib.h>
#endif /* USE_ZLIB */

/*****************************************************************************/

/*
 * TODO:
 *      - compact table to bitlevel representation
 *      - iteratively create larger tables until absolute limit is reached
 *        of fill ratio is < 1%
 */
#define DEFAULT_TABLE_BITS   (17)
#define DEFAULT_TABLE_SIZE   (1UL << DEFAULT_TABLE_BITS)  /* 128k */

#define MAX_TABLE_SIZE       (2 * 1024 * 1024)   /* 2 MB */

/*
 * magical constant necessary for the query routing hash function
 */
#define MULTIPLIER           0x4F1BBCDC

/*
 * How often to synchronize the QRT with ultrapeers
 */
#define UPDATE_INTERVAL      (3 * MINUTES)

/*
 * How often we check to build a compressed patch of local shares.
 */
#define BUILD_TABLE_INTERVAL (30 * SECONDS)

/*
 * Largest hops value in table. It looks like Limewire hardcodes
 * this as 7, and won't understand any other value.
 */
#define INFINITY             7

/*
 * Constants for changing route table.
 */
#define QR_KEYWORD_ADD       (1 - INFINITY)
#define QR_KEYWORD_REMOVE    (INFINITY - 1)

/*
 * The minimum length of a keyword
 */
#define QRP_MIN_LENGTH        3

/*
 * Maximum patch fragment size to send
 */
#define PATCH_FRAGSIZE       2048

/*
 * This interface presumes a specific size for the route table.  If we
 * decide to make the table bigger at runtime, then the indices need to
 * be regenerated by running over all the shares and then all the
 * indices.
 *
 * This could be fixed by holding the full 32-bit index of each hash
 * word, and then discarding the lower (32 - DEFAULT_TABLE_BITS) bits
 * only just before inserting into the qrp hash table. Then we only have
 * to iterate over the indices.
 */
struct route_table_entry
{
	int        ref;                    /* number of references to this index */
	uint32_t   index;                  /* the actual position */
};

/*****************************************************************************/

/*
 * The set of indices that are currently marked "present" in the
 * routing table.
 */
static Dataset       *indices;

/*
 * This holds the compressed table as a full QRP patch (incremental
 * updates not supported yet).
 */
static unsigned char *compressed_table;
static size_t         compressed_size;

/*
 * Keeps track of how many times the compressed table has changed.
 * Used to avoid sending updates when not necessary.
 */
static int            compressed_version;

/*
 * Timer that bulids the compressed patch for the table submitted
 * to peers.
 */
static timer_id       compress_timer;

/*
 * The full query-routing table in binary form. This will get
 * compressed before transmission.
 */
static unsigned char *full_table;
static size_t         table_size;

/*
 * Statistics about the current table
 */
static size_t         nr_present;
static size_t         nr_shared;

/*****************************************************************************/

/* hash function used for query-routing */
uint32_t gt_query_router_hash_str (char *str, size_t bits)
{
	uint32_t      hash;
	unsigned int  i;
	unsigned char c;

	i = hash = 0;

	while ((c = *str++) && !isspace (c))
	{
		hash ^= tolower (c) << (i * 8);

		/* using & instead of %, sorry */
		i = (i+1) & 0x03;
	}

	return (hash * MULTIPLIER) >> (32 - bits);
}

/*****************************************************************************/

static char *zlib_strerror (int error)
{
#ifndef USE_ZLIB
	return NULL;
#else /* USE_ZLIB */
	switch (error)
	{
	 case Z_OK:             return "OK";
	 case Z_STREAM_END:     return "End of stream";
	 case Z_NEED_DICT:      return "Decompressing dictionary needed";
	 case Z_STREAM_ERROR:   return "Stream error";
	 case Z_ERRNO:          return "Generic zlib error";
	 case Z_DATA_ERROR:     return "Data error";
	 case Z_MEM_ERROR:      return "Memory error";
	 case Z_BUF_ERROR:      return "Buffer error";
	 case Z_VERSION_ERROR:  return "Incompatible runtime zlib library";
	 default:               break;
	}

	return "Invalid zlib error code";
#endif /* USE_ZLIB */
}

/* TODO: make this use a stream-like interface */
static unsigned char *compress_table (unsigned char *table, size_t in_size,
                                      size_t *out_size)
{
#ifndef USE_ZLIB
	*out_size = 0;
	return NULL;
#else /* USE_ZLIB */
	z_streamp      out;
	int            ret;
	unsigned char *out_buf;
	int            free_size;

	*out_size = 0;

	if (!(out = MALLOC (sizeof (*out))))
		return NULL;

	if ((ret = deflateInit (out, Z_DEFAULT_COMPRESSION)) != Z_OK)
	{
		GT->DBGFN (GT, "deflateInit error: %s", zlib_strerror (ret));
		free (out);
		return NULL;
	}

	/* allocate initial buffer */
	free_size = DEFAULT_TABLE_SIZE / 2; /* a real waste */

	if (!(out_buf = malloc (free_size)))
	{
		deflateEnd (out);
		free (out);
		return NULL;
	}

	out->next_in   = table;
	out->avail_in  = in_size;
	out->next_out  = out_buf;
	out->avail_out = free_size;

	if ((ret = deflate (out, Z_FINISH)) != Z_STREAM_END)
	{
		GT->DBGFN (GT, "compression error: %s", zlib_strerror (ret));
		deflateEnd (out);
		free (out);
		return NULL;
	}

	*out_size = free_size - out->avail_out;

	deflateEnd (out);
	free (out);

	return out_buf;
#endif /* USE_ZLIB */
}

static int compress_qrp_table (void *udata)
{
	unsigned char *new_table;
	size_t         new_size;
	StopWatch     *sw;
	double         elapsed;

	if (!full_table || table_size == 0)
		return TRUE;

	sw = stopwatch_new (TRUE);

	/* compress a new table */
	new_table = compress_table (full_table, table_size, &new_size);

	elapsed = stopwatch_free_elapsed (sw);

	GT->DBGFN (GT, "%.4lfs elapsed compressing", elapsed);
	GT->DBGFN (GT, "present=%u shared=%u", nr_present, nr_shared);
	GT->DBGFN (GT, "filled ratio=%.4lf%%",
	           (double) nr_present * 100 / DEFAULT_TABLE_SIZE);

	if (!new_table)
		return TRUE;

	assert (new_size > 0);

	/*
	 * Replace the old compressed table
	 */
	free (compressed_table);

	compressed_table = new_table;
	compressed_size  = new_size;

	compressed_version++;

	if (!compressed_version)
		compressed_version++;

	/* remove the timer, as the table is now up to date */
	compress_timer = 0;
	return FALSE;
}

static void start_compress_timer (void)
{
	if (compress_timer)
		return;

	compress_timer = timer_add (BUILD_TABLE_INTERVAL,
	                            (TimerCallback) compress_qrp_table,
	                            NULL);
}

/* TODO: this should be moved to gt_self */
unsigned char *gt_query_router_self (size_t *size, int *version)
{
	if (!compressed_table)
		return NULL;

	assert (size != NULL && version != NULL);

	*size    = compressed_size;
	*version = compressed_version;

	return compressed_table;
}

static int free_entries (ds_data_t *key, ds_data_t *value, void *udata)
{
	struct route_table_entry *entry = value->data;

	free (entry);

	return DS_CONTINUE | DS_REMOVE;
}

void gt_query_router_self_destroy (void)
{
	timer_remove_zero (&compress_timer);

	free (full_table);
	full_table = NULL;
	table_size = 0;

	free (compressed_table);
	compressed_table   = NULL;
	compressed_size    = 0;
	compressed_version = 0;

	nr_present = 0;
	nr_shared  = 0;

	dataset_foreach_ex (indices, DS_FOREACH_EX(free_entries), NULL);
	dataset_clear (indices);
	indices = NULL;
}

void gt_query_router_self_init (void)
{
	full_table = malloc (DEFAULT_TABLE_SIZE);
	table_size = DEFAULT_TABLE_SIZE;

	memset (full_table, 0, DEFAULT_TABLE_SIZE);

	indices = dataset_new (DATASET_HASH);
}

/*****************************************************************************/

static uint32_t *append_token (uint32_t *tokens, size_t *len,
                                size_t pos, uint32_t tok)
{
	if (pos >= *len)
	{
		uint32_t *new_tokens;

		*(len) += 8;
		new_tokens = realloc (tokens, *len * sizeof (uint32_t));

		assert (new_tokens != NULL);
		tokens = new_tokens;
	}

	tokens[pos] = tok;
	return tokens;
}

static uint32_t *tokenize (char *hpath, size_t *r_len)
{
	uint32_t *tokens;
	int        count;
	size_t     len;
	char      *str, *str0;
	char      *next;

	if (!(str0 = str = STRDUP (hpath)))
		return NULL;

	tokens = NULL;
	len    = 0;
	count  = 0;

	while ((next = string_sep_set (&str, QRP_DELIMITERS)) != NULL)
	{
		uint32_t tok;

		if (string_isempty (next))
			continue;

		/* don't add keywords that are too small */
		if (strlen (next) < QRP_MIN_LENGTH)
			continue;

		tok = gt_query_router_hash_str (next, DEFAULT_TABLE_BITS);
		tokens = append_token (tokens, &len, count++, tok);
	}

	*r_len = count;

	free (str0);
	return tokens;
}

static void set_entry (uint32_t index)
{
	uint8_t   old_entry;

	if (!full_table)
		return;

	assert (index < table_size);

	old_entry = full_table[index];
	full_table[index] = QR_KEYWORD_ADD;

	assert (old_entry == 0 || old_entry == QR_KEYWORD_REMOVE);
#if 0
	GT->dbg (GT, "+%u", index);
#endif

	nr_present++;
}

static void clear_entry (uint32_t index)
{
	uint8_t   old_entry;

	if (!full_table)
		return;

	assert (index < table_size);

	/*
	 * This needs to change when doing incremental updating...
	 */
	old_entry = full_table[index];
	full_table[index] = QR_KEYWORD_REMOVE;

	assert (old_entry == (uint8_t) QR_KEYWORD_ADD);
#if 0
	GT->dbg (GT, "-%u", index);
#endif

	nr_present--;
}

void gt_query_router_self_add (FileShare *file)
{
	uint32_t                 *tokens, *tokens0;
	uint32_t                  tok;
	size_t                    len;
	int                       i;
	struct route_table_entry *entry;

	tokens0 = tokens = tokenize (share_get_hpath (file), &len);

	assert (tokens != NULL);
	assert (len > 0);

	for (i = 0; i < len; i++)
	{
		tok = tokens[i];

		if ((entry = dataset_lookup (indices, &tok, sizeof (tok))))
		{
			entry->ref++;

			if (entry->ref == 2)
				nr_shared++;

			continue;
		}

		/*
		 * Create a new index and add it to the table
		 */
		if (!(entry = malloc (sizeof (struct route_table_entry))))
			continue;

		entry->ref   = 1;
		entry->index = tok;

		set_entry (tok);
		dataset_insert (&indices, &tok, sizeof (tok), entry, 0);

		/*
		 * The table has changed. Start the timer to rebuild
		 * a QRP patch.
		 */
		start_compress_timer ();
	}

	free (tokens0);
}

void gt_query_router_self_remove (FileShare *file)
{
	uint32_t                 *tokens, *tokens0;
	uint32_t                  tok;
	size_t                    len;
	int                       i;
	struct route_table_entry *entry;

	tokens0 = tokens = tokenize (share_get_hpath (file), &len);

	assert (tokens != NULL);
	assert (len > 0);

	for (i = 0; i < len; i++)
	{
		tok = tokens[i];

		entry = dataset_lookup (indices, &tok, sizeof (tok));
		assert (entry != NULL);

		if (--entry->ref > 0)
		{
			if (entry->ref == 1)
				nr_shared--;

			continue;
		}

		clear_entry (tok);
		dataset_remove (indices, &tok, sizeof (tok));

		/*
		 * The table has changed. Start the timer to rebuild
		 * a QRP patch.
		 */
		start_compress_timer ();
	}

	free (tokens0);
}

/*****************************************************************************/

int query_patch_open (GtQueryRouter *router, int seq_size, int compressed,
                      size_t max_size)
{
	GtQueryPatch *new_patch;

	if (!(new_patch = malloc (sizeof (GtQueryPatch))))
		return FALSE;

	memset (new_patch, 0, sizeof (GtQueryPatch));

	if (!(new_patch->stream = zlib_stream_open (max_size)))
	{
		free (new_patch);
		return FALSE;
	}

	new_patch->seq_size   = seq_size;
	new_patch->compressed = compressed;

	/* NOTE: sequence is 1-based, not 0-based */
	new_patch->seq_num = 1;

	router->patch = new_patch;

	return TRUE;
}

void query_patch_close (GtQueryRouter *router)
{
	GtQueryPatch *patch;

	GT->DBGFN (GT, "entered");

	if (!router)
		return;

	patch = router->patch;

	if (!patch)
		return;

	zlib_stream_close (patch->stream);

	router->patch = NULL;
	free (patch);
}

/* TODO: compact router tables to bit-level */
static void query_patch_apply (GtQueryRouter *router, int bits, char *data,
                               size_t data_size)
{
	GtQueryPatch   *patch;
	char           *table;          /* NOTE: this must be signed */
	int             i;

	patch = router->patch;
	assert (patch != NULL);

	/* check for overflow: this may look wrong but its not */
	if (patch->table_pos + (data_size - 1) >= router->size)
	{
		GT->DBGFN (GT, "patch overflow: %u (max of %u)",
		           patch->table_pos+data_size, router->size);
		query_patch_close (router);
		return;
	}

	table = router->table;

	/* hrm */
	if (bits == 4)
	{
		int j;

		for (i = 0; i < data_size; i++)
		{
			int pos;
			char change;

			pos = i + patch->table_pos;

			/* avoid % */
			j = (i+1) & 0x1;

			/* grab the correct half of the byte and sign-extend it
			 * NOTE: this starts off with the most significant bits! */
			change = data[i] & (0x0f << (4 * j));

			/* move to least significant bits
			 * TODO: does this do sign-extension correctly? */
			change >>= 4;

			table[pos] += change;
		}
	}
	else if (bits == 8)
	{
		/* untested */
		for (i = 0; i < data_size; i++)
		{
			table[i + patch->table_pos] += data[i];
		}
	}
	else
	{
		GT->DBGFN (GT, "undefined bits value in query patch: %u", bits);
		query_patch_close (router);
		return;
	}

	/* store the table position for the next patch */
	patch->table_pos += i;

	/* cleanup the data if the patch is done */
	patch->seq_num++;

	if (patch->seq_num > patch->seq_size)
		query_patch_close (router);
}

/*****************************************************************************/

/* TODO: compact router tables to bit-level */
GtQueryRouter *gt_query_router_new (size_t size, int infinity)
{
	GtQueryRouter *router;

	if (size > MAX_TABLE_SIZE)
		return NULL;

	if (!(router = malloc (sizeof (GtQueryRouter))))
		return NULL;

	memset (router, 0, sizeof (GtQueryRouter));

	if (!(router->table = malloc (size)))
	{
		free (router->table);
		return NULL;
	}

	memset (router->table, infinity, size);

	router->size = size;

	return router;
}

void gt_query_router_free (GtQueryRouter *router)
{
	if (!router)
		return;

	query_patch_close (router);

	free (router->table);
	free (router);
}

/*****************************************************************************/

void gt_query_router_update (GtQueryRouter *router, size_t seq_num,
                             size_t seq_size, int compressed, int bits,
                             unsigned char *zdata, size_t size)
{
	GtQueryPatch *patch;
	char         *data;

	if (!router)
	{
		GT->DBGFN (GT, "null router");
		return;
	}

	if (!router->patch)
	{
		if (!query_patch_open (router, seq_size, compressed, router->size))
			return;
	}

	patch = router->patch;

	/* check for an invalid sequence number or size */
	if (patch->seq_size != seq_size || patch->seq_num != seq_num)
	{
		GT->DBGFN (GT, "bad patch: seq_size %u vs %u, seq_num %u vs %u",
		           patch->seq_size, seq_size, patch->seq_num, seq_num);
		query_patch_close (router);
		return;
	}

	if (compressed != patch->compressed)
	{
		GT->DBGFN (GT, "tried to change encodings in patch");
		query_patch_close (router);
		return;
	}

	switch (compressed)
	{
	 case 0x00: /* no compression */
		if (!zlib_stream_write (patch->stream, zdata, size))
		{
			GT->DBGFN (GT, "error copying data");
			query_patch_close (router);
			return;
		}

		break;

	 case 0x01: /* deflate */
		printf ("zlib compressed data:\n");
		print_hex (zdata, size);

		if (!zlib_stream_inflate (patch->stream, zdata, size))
		{
			GT->DBGFN (GT, "error inflating data");
			query_patch_close (router);
			return;
		}

		break;

	 default:
		GT->DBGFN (GT, "unknown compression algorithm in query route patch");
		return;
	}

	/* read the data in the stream */
	if (!(size = zlib_stream_read (patch->stream, &data)))
	{
		GT->DBGFN (GT, "error calling zlib_stream_read");
		query_patch_close (router);
		return;
	}

	printf ("after uncompressing:\n");
	print_hex (data, size);

	/* apply the patch -- this will cleanup any data if necessary */
	query_patch_apply (router, bits, data, size);

	print_hex (router->table, router->size);
}

/*****************************************************************************/

static void submit_empty_table (TCPC *c)
{
	static char table[128] = { 0 };

#if 0
	size_t      size;
#endif

	GT->DBGFN (GT, "reseting route table for %s", net_ip_str (GT_NODE(c)->ip));

	/* set the table to all ones for an empty route table patch */
	if (table[0] != QR_KEYWORD_REMOVE)
		memset (table, QR_KEYWORD_REMOVE, sizeof (table));

#if 0
	/* TEST: set part of the table to -infinity to get queries */
	size = sizeof (table);
	memset (table + (size + 1) / 2 - 1, -infinity, (size + 1) / 4);
#endif

	/* format: <query-route-msg-type> <length of table> <infinity> */
	if (gt_packet_send_fmt (c, GT_QUERY_ROUTE, NULL, 1, 0,
	                        "%c%lu%c", 0, (unsigned long) sizeof (table),
	                        INFINITY) < 0)
	{
		GT->DBGFN (GT, "error reseting table");
		return;
	}

	if (gt_packet_send_fmt (c, GT_QUERY_ROUTE, NULL, 1, 0,
	                        "%c%c%c%c%c%*p",
	                        1, 1, 1, 0, 8, sizeof (table), table) < 0)
	{
		GT->DBGFN (GT, "error sending empty patch");
		return;
	}
}

static void submit_table (TCPC *c, unsigned char *table, size_t size)
{
	int             infinity = 2;
	int             seq_size;
	int             compressed;
	int             seq_num;
	unsigned char  *p;
	size_t          send_size;

	/* XXX make table size settable at runtime */

	/* send a reset table first */
	if (gt_packet_send_fmt (c, GT_QUERY_ROUTE, NULL, 1, 0,
	                        "%c%lu%c", 0, DEFAULT_TABLE_SIZE, infinity) < 0)
	{
		GT->DBGFN (GT, "error reseting table");
		return;
	}

	/* Break the table into PATCH_FRAGSIZE-sized chunks,
	 * and include any leftover portions. */
	seq_size = size / PATCH_FRAGSIZE +
	           (size % PATCH_FRAGSIZE == 0 ? 0 : 1);

	assert (seq_size < 256);
	GT->dbg (GT, "sequence size: %u", seq_size);

	p = table;
	compressed = TRUE;

	/* NOTE: patch sequence numbers start at 1 */
	for (seq_num = 1; seq_num <= seq_size; seq_num++)
	{
		send_size = MIN (PATCH_FRAGSIZE, size);

		if (gt_packet_send_fmt (c, GT_QUERY_ROUTE, NULL, 1, 0,
		                        "%c%c%c%c%c%*p",
		                        /* QRP PATCH */ 1,
		                        seq_num, seq_size, compressed,
		                        /* bits */ 8,
		                        send_size, p) < 0)
		{
			GT->DBGFN (GT, "error sending empty patch");
			return;
		}

		size -= send_size;
		p += send_size;
	}
}

static int submit_timer (TCPC *c)
{
	assert (GT_NODE(c)->state & GT_NODE_CONNECTED);

	query_route_table_submit (c);
	return TRUE;
}

void query_route_table_submit (TCPC *c)
{
	size_t         size;
	int            version;
	unsigned char *table;
	int            sent_table;

	/* Whether we have sent a table to this node already. This is a
	 * a hacky way to represent that by using the table refresh timer */
	sent_table = GT_NODE(c)->query_route_timer;

	table = gt_query_router_self (&size, &version);

	if (table != NULL)
	{
		/* dont submit a table if this node is already up to date */
		if (GT_NODE(c)->query_router_counter == version)
			return;

		submit_table (c, table, size);

		/* store the version number of this table so
		 * we dont resubmit unecessarily */
		GT_NODE(c)->query_router_counter = version;
	}
	else if (!sent_table)
	{
		/* Send the table, but only if we havent sent a table already */
		submit_empty_table (c);
	}

	/* continually refresh the node's query routes */
	if (!GT_NODE(c)->query_route_timer)
	{
		GT_NODE(c)->query_route_timer = timer_add (UPDATE_INTERVAL,
		                                        (TimerCallback) submit_timer,
		                                        c);
	}
}

/*****************************************************************************/
/* TESTING */

#if 0
#define CHECK(x) do { \
	if (!(x)) printf("FAILED: %s\n", #x); \
	else printf("OK: %s\n", #x); \
} while (0)

#define HASH(str, bits) \
	printf ("hash " str ": %u\n", gt_query_router_hash_str (str, bits))

int main (int argc, char **argv)
{
#define hash gt_query_router_hash_str

	CHECK(hash("", 13)==0);
	CHECK(hash("eb", 13)==6791);
	CHECK(hash("ebc", 13)==7082);
	CHECK(hash("ebck", 13)==6698);
	CHECK(hash("ebckl", 13)==3179);
	CHECK(hash("ebcklm", 13)==3235);
	CHECK(hash("ebcklme", 13)==6438);
	CHECK(hash("ebcklmen", 13)==1062);
	CHECK(hash("ebcklmenq", 13)==3527);
	CHECK(hash("", 16)==0);
	CHECK(hash("n", 16)==65003);
	CHECK(hash("nd", 16)==54193);
	CHECK(hash("ndf", 16)==4953);
	CHECK(hash("ndfl", 16)==58201);
	CHECK(hash("ndfla", 16)==34830);
	CHECK(hash("ndflal", 16)==36910);
	CHECK(hash("ndflale", 16)==34586);
	CHECK(hash("ndflalem", 16)==37658);
	CHECK(hash("FAIL", 16)==37458);	// WILL FAIL
	CHECK(hash("ndflaleme", 16)==45559);
	CHECK(hash("ol2j34lj", 10)==318);
	CHECK(hash("asdfas23", 10)==503);
	CHECK(hash("9um3o34fd", 10)==758);
	CHECK(hash("a234d", 10)==281);
	CHECK(hash("a3f", 10)==767);
	CHECK(hash("3nja9", 10)==581);
	CHECK(hash("2459345938032343", 10)==146);
	CHECK(hash("7777a88a8a8a8", 10)==342);
	CHECK(hash("asdfjklkj3k", 10)==861);
	CHECK(hash("adfk32l", 10)==1011);
	CHECK(hash("zzzzzzzzzzz", 10)==944);

	CHECK(hash("3nja9", 10)==581);
	CHECK(hash("3NJA9", 10)==581);
	CHECK(hash("3nJa9", 10)==581);

	printf ("hash(FAIL, 16) = %u\n", hash("FAIL", 16));
	return 0;
}
#endif
