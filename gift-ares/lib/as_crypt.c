/*
 * $Id: as_crypt.c,v 1.21 2005/11/26 01:42:36 mkern Exp $
 *
 * Copyright (C) 2004 Markus Kern <mkern@users.berlios.de>
 * Copyright (C) 2004 Tom Hargreaves <hex@freezone.co.uk>
 *
 * All rights reserved.
 */

#include "as_ares.h"

/*****************************************************************************/

unsigned short table_1[256] =
{
	0x0000, 0x0808, 0xDC6C, 0x33DC, 0x45DD, 0xABF0, 0x5195, 0x296B, 0x5F4A,
	0x6CF8, 0x14FE, 0x798B, 0x1210, 0xD741, 0x0F4A, 0x4B15, 0xEAD2, 0x5E2E,
	0xC64F, 0x53F2, 0xB29A, 0xD81A, 0xB7CD, 0x4E7F, 0x29A1, 0x5459, 0x774C,
	0x3F24, 0xD35E, 0x476E, 0x7B54, 0x2630, 0xDFD3, 0x498B, 0xC5D2, 0xF9F8,
	0x7E15, 0xE34E, 0xD3C7, 0x0532, 0x241C, 0x24BC, 0x8034, 0x058C, 0x97C9,
	0x0278, 0xC643, 0xA690, 0xC53D, 0xB545, 0x8EB8, 0x34BE, 0xAE5A, 0x97C4,
	0xF497, 0xA4E0, 0xFF94, 0x3E68, 0xAD18, 0x4BB2, 0x15FC, 0xC5B6, 0x7ECA,
	0xE1B5, 0x828C, 0x92C4, 0xF403, 0xAF50, 0x56B5, 0x01F2, 0xB491, 0xFD2A,
	0xC627, 0xBFE3, 0x329C, 0x24C5, 0xE9E0, 0xC8C0, 0x96DA, 0xDD5C, 0xB079,
	0x49AF, 0x17F8, 0xA100, 0x47AF, 0xE08E, 0x2946, 0x45EF, 0x8B2E, 0xF5F5,
	0x2CA2, 0x2835, 0x44A3, 0x2D6D, 0x93A8, 0x7F86, 0x4901, 0x27EB, 0x9C18,
	0xBD5B, 0xBF13, 0x1491, 0x138A, 0x0F4D, 0x1B45, 0xCBA6, 0xCE4D, 0x61B0,
	0x9CAD, 0x6FD3, 0xBDA6, 0x7E71, 0x575E, 0xD1A1, 0xD128, 0x2432, 0x17EF,
	0x1131, 0x0F6F, 0x31A4, 0xAC46, 0x3A3B, 0x9202, 0x4125, 0x5DAB, 0xD64A,
	0x5087, 0x509B, 0xA80A, 0xB137, 0xE729, 0x5192, 0x7A8A, 0x4BE5, 0xC448,
	0xBD92, 0x8D4D, 0xB93C, 0x6961, 0x8AC3, 0x9887, 0xE169, 0xAB3E, 0x1CC5,
	0x78C2, 0x6755, 0x1D60, 0x0DCB, 0x8C71, 0xAC64, 0x14AA, 0xEBF6, 0xD6B4,
	0xAE70, 0xED4F, 0x46FA, 0xB36C, 0xBC06, 0x7FFF, 0xA9EC, 0x2881, 0x3AE1,
	0xF24E, 0x5D6B, 0x206F, 0xFCA5, 0x4E66, 0x0DF1, 0x1A18, 0xDDDE, 0x8DEF,
	0xB278, 0x19C6, 0xAB39, 0x043C, 0x4F51, 0xE77F, 0x8903, 0x53B8, 0x7142,
	0xE68F, 0x58E0, 0x5A90, 0x7CE0, 0x1251, 0xD9CD, 0xC2A2, 0x2E2D, 0xEC3E,
	0x7E59, 0x20A8, 0xE471, 0x673A, 0x3521, 0xCE9E, 0x965F, 0x1C1C, 0x9F8A,
	0xED7A, 0x8A62, 0x537C, 0x72C4, 0x3A0E, 0x2F46, 0xB0C2, 0xFEFC, 0xA136,
	0xB10D, 0x8A6C, 0x18E2, 0xBF47, 0x2611, 0x3BA1, 0xE15C, 0xB6B9, 0x7057,
	0xFAF3, 0x278A, 0x0A14, 0x2F34, 0x027B, 0x60FA, 0x6519, 0x5D23, 0x1511,
	0x742E, 0x8133, 0x75E6, 0xACE8, 0xD14C, 0x911E, 0x40DD, 0x5F53, 0x9525,
	0xDFD7, 0x9BA4, 0x41D4, 0xB26A, 0x8EC5, 0xE0F2, 0x5C62, 0x5D2B, 0x9F26,
	0xC7AE, 0x74FD, 0x3491, 0xB2BD, 0xD653, 0xC075, 0xE6DD, 0x2FBB, 0xC688,
	0x4478, 0x4BA2, 0xB3EB, 0x74F9
};

unsigned short table_2[256] = 
{
	0xCBA6, 0x1C3E, 0x60AE, 0x384F, 0x6800, 0xB1B7, 0x946F, 0xCDCB, 0xFCB6,
	0xE274, 0xDBB8, 0x50F5, 0x95FC, 0x3EDB, 0x69BA, 0x67B5, 0x6F11, 0xA3A4,
	0xD43D, 0x1DE6, 0x1DE5, 0x83E6, 0xB5DD, 0x007C, 0xCAED, 0x705E, 0x8280,
	0x33F2, 0x5144, 0x27FF, 0x0A1C, 0xF1F7, 0x6304, 0xBDC1, 0x65A9, 0x1A59,
	0x0DE4, 0x9FA3, 0x4A61, 0xC332, 0x3C13, 0x8B03, 0xFF40, 0xF453, 0x0D55,
	0xBA20, 0x70BA, 0xF9EF, 0x245D, 0xD6ED, 0x1EB7, 0xFA8A, 0x446B, 0x7F1A,
	0xE0D5, 0xBC22, 0xDB27, 0x655E, 0xBCDF, 0xC49D, 0x52BD, 0x5C07, 0x4B89,
	0x4173, 0x483B, 0xD4C6, 0x676F, 0x629D, 0x0229, 0xA1B5, 0x224E, 0x14BE,
	0xC368, 0x03AA, 0x3C83, 0x4691, 0xD64D, 0x51C1, 0x9AC2, 0x2594, 0x6BFE,
	0xC624, 0x7618, 0xFDF4, 0xAC0D, 0x3C1F, 0x4224, 0xA9B9, 0x9055, 0xEB62,
	0x8593, 0xBB34, 0x6912, 0x6C97, 0x20DB, 0xCEA6, 0x2545, 0x9325, 0xBF39,
	0xAF33, 0xBB47, 0xE843, 0x6DEE, 0x3B07, 0x4DAD, 0xD342, 0x95B6, 0x32C7,
	0xE85C, 0xBB14, 0xD28B, 0x603C, 0xF1EE, 0xAD22, 0x6599, 0xC03C, 0xAD45,
	0x554D, 0x3D82, 0x9BDA, 0x676F, 0x5343, 0xD0D4, 0xBCCF, 0x2DBA, 0x3905,
	0x46C9, 0x2928, 0x2818, 0xBEB6, 0xAA3F, 0x1232, 0xF3B7, 0xF7A7, 0x22F8,
	0xE2A4, 0x99D9, 0x94A2, 0x7114, 0x980D, 0xFEFB, 0x7F74, 0x26CC, 0xD37E,
	0xE624, 0x5BBE, 0x5C71, 0x4D79, 0xE48A, 0xB8FD, 0xDAA6, 0x991A, 0xE16C,
	0x01D8, 0xF6DB, 0x6285, 0xFE2D, 0x74AB, 0x9E0B, 0x9491, 0x02AE, 0xB152,
	0x49B8, 0x11B4, 0xA9EF, 0xA839, 0xDB24, 0xEC2F, 0x6AE6, 0xF6A2, 0x98D2,
	0x497B, 0x99A0, 0xFC36, 0xCA3E, 0x5CF4, 0xFC97, 0x35D0, 0xADD9, 0x25C5,
	0x3254, 0xA986, 0xC549, 0xDC14, 0x8346, 0x6FFA, 0xB3E0, 0x3970, 0xFBE3,
	0xA6E0, 0x2B5B, 0x0879, 0xEAFE, 0x58D1, 0xA2DD, 0xA7CF, 0x2068, 0x2650,
	0xD42B, 0x6C3E, 0x87CB, 0xBC1A, 0x3B2B, 0x0E28, 0xFBC4, 0x62B4, 0x1398,
	0x8E34, 0x6D41, 0x3330, 0x9109, 0x3D36, 0xBB1B, 0xBD40, 0x4D22, 0xD35F,
	0xD5F4, 0x2A7F, 0x281A, 0xC2A6, 0x0C54, 0x2AFD, 0x176E, 0x3077, 0x9B00,
	0x3709, 0x9EE5, 0x429C, 0xDD9B, 0xF244, 0xEFC5, 0xAB6A, 0xBB81, 0xBBE3,
	0xEA55, 0xA12D, 0x2CE0, 0xB845, 0x7D94, 0xACD6, 0xF419, 0xDFB7, 0x2138,
	0xFBE5, 0xE757, 0xDE84, 0x65EA, 0x2192, 0x666F, 0xD241, 0xD7C2, 0x7340,
	0xD8F8, 0x3058, 0xAEFF, 0x6C24
};

unsigned short table_3[256] = 
{
	0x777F, 0x99EF, 0x65B7, 0x999E, 0x016E, 0xA28B, 0x413A, 0x4A42, 0x3FC3,
	0xB8A8, 0x89C6, 0x7FA9, 0xEBEA, 0x95CD, 0x2330, 0xC1F1, 0xD721, 0xDBA7,
	0xAF08, 0x56DB, 0xB3D9, 0x72D4, 0x9695, 0x63B3, 0x6F4D, 0xBAF0, 0x2B0F,
	0x7E87, 0xB762, 0x97DE, 0x181D, 0xDA86, 0x88BF, 0xA859, 0xA490, 0x7BB6,
	0xE12E, 0x31BC, 0x7D5E, 0x1DDB, 0xF233, 0x8D10, 0x06E3, 0xBAA4, 0x6FEB,
	0x2154, 0x7054, 0xDB19, 0xD828, 0x3712, 0x0584, 0x2043, 0xCDCB, 0x311F,
	0x7ADC, 0xAF1B, 0xE463, 0xF6B3, 0x2F96, 0x6BB5, 0x7805, 0x9AAB, 0xA23B,
	0x2FAE, 0x6D6B, 0x8C1B, 0x935D, 0x67D4, 0xF650, 0xDC18, 0x9296, 0xC516,
	0xB60C, 0x64C5, 0xF1C2, 0xECAC, 0xE26D, 0xDD9C, 0x5A79, 0x5388, 0x3CD6,
	0x2900, 0x81D1, 0xB0FE, 0xFF9C, 0x6701, 0xB653, 0xB4B0, 0x1B9E, 0x9970,
	0x443C, 0xEBBD, 0x6223, 0xE524, 0xEBF6, 0x012A, 0x76FA, 0xBC8C, 0xE6D7,
	0xC592, 0xA6CD, 0x7F76, 0x361A, 0xAA0B, 0xFDC6, 0x5C1F, 0x381C, 0x9A59,
	0x3A67, 0x7D7D, 0xBFD9, 0x6257, 0x78A4, 0xD2C9, 0x2AA6, 0x0AA4, 0xB142,
	0xFC51, 0x3031, 0xD88B, 0x6975, 0x297E, 0x68B8, 0xDD35, 0x2EB6, 0xF422,
	0xC587, 0x4012, 0xBAE3, 0x8504, 0x77B6, 0xB086, 0xDC9C, 0x8DAE, 0x0121,
	0xAAD2, 0x7FDA, 0xE377, 0x6BA8, 0x7C43, 0x72D1, 0xC7CD, 0xE2A9, 0x329E,
	0xC308, 0x29C6, 0x2ABC, 0xE2CC, 0xCEB7, 0x6CE8, 0xB3AF, 0xF2C3, 0x6662,
	0x8135, 0x40C3, 0x52B6, 0x9AB5, 0x587B, 0x6326, 0xD17E, 0x12A0, 0x04DC,
	0x42B1, 0xF849, 0x05B4, 0x0C99, 0x70E4, 0x1982, 0x36BE, 0xBF24, 0xC21F,
	0x7F01, 0x8AA2, 0x9766, 0x6924, 0xE375, 0x177B, 0xF74F, 0xD0CB, 0xA310,
	0xC7F2, 0xC89D, 0xF005, 0x4F72, 0xEEDC, 0xCEEE, 0x1414, 0x92D8, 0x6718,
	0xB709, 0x5D0A, 0x8E86, 0x1BA8, 0x2F6A, 0x6881, 0x2073, 0x140F, 0x960E,
	0xE69A, 0xBC35, 0x60EB, 0x077F, 0x1539, 0xC32D, 0x84D4, 0xDB20, 0x5D7F,
	0x87F4, 0x3576, 0xD8BA, 0x8F8A, 0x6906, 0x90EA, 0xB348, 0x786A, 0xAEAE,
	0x235B, 0x9500, 0xCE64, 0x1833, 0x58D7, 0xC8A4, 0xAF6B, 0x4441, 0x3773,
	0xCC09, 0x2DDD, 0x609B, 0x7DA4, 0x57E5, 0xA77B, 0xCD01, 0x80DA, 0x28DE,
	0xE2AD, 0x9D5D, 0x685E, 0x95D1, 0x2DF5, 0x2732, 0xA06F, 0x3F61, 0xFDB1,
	0x0647, 0xA199, 0x64C1, 0xC416, 0x4490, 0x6857, 0xA9C4, 0xFF6A, 0x915E,
	0x38EA, 0x5A23, 0xBA83, 0xB3C9
};

unsigned char table_4[256] =
{
	0xD7, 0xEF, 0xE0, 0x80, 0x19, 0xE1, 0x4B, 0x3C, 0xC3, 0x47, 0x10, 0xE2,
	0xA6, 0x1E, 0x76, 0x41, 0xA2, 0xC6, 0xEB, 0x32, 0x25, 0x11, 0xDB, 0xC7,
	0x21, 0x54, 0x92, 0xC5, 0x5F, 0x58, 0xC1, 0x2F, 0x2C, 0xD2, 0xB1, 0x0E,
	0x36, 0x86, 0x14, 0xD3, 0x70, 0x89, 0x97, 0xD9, 0x0D, 0xFC, 0x7F, 0x04,
	0x2D, 0x5C, 0x2B, 0x4D, 0x56, 0x7B, 0x9D, 0xF2,	0xB8, 0x71, 0x0A, 0xBF,
	0xB3, 0x6C, 0x9B, 0xAD, 0xC2, 0xFB, 0x27, 0xAF, 0x1D, 0x65, 0xE6, 0xBE,
	0x94, 0x8B, 0xC9, 0xC0, 0xF5, 0xCC, 0xBA, 0xDD, 0x6A, 0x59, 0x9E, 0x74,
	0x0B, 0x75, 0x1C, 0xD6, 0x0C, 0xD5, 0xFA, 0x35, 0x4C, 0xB4, 0xB5, 0x88,
	0x8F, 0x1F, 0x6E, 0x61, 0x1A, 0x28, 0xE7, 0x03, 0x40, 0xEE, 0xE5, 0xF8,
	0x77, 0x69, 0x07, 0x64, 0x06, 0x93, 0x67, 0x48, 0xD0, 0x3F, 0x20, 0xD1,
	0x3D, 0xA4, 0x5B, 0x23, 0x05, 0x85, 0xB2, 0x8D, 0x5A, 0xF1, 0x1B, 0xCD,
	0x44, 0x33, 0x9F, 0x81, 0x37, 0xFE, 0x24, 0x7E, 0x8A, 0xA8, 0x62, 0xCF,
	0x16, 0x46, 0xBD, 0x7C, 0x6B, 0xDC, 0xA5, 0x91, 0xCE, 0xCB, 0x18, 0x3E,
	0x99, 0x60, 0xDA, 0xC4, 0x79, 0x9C, 0xA9, 0x8C, 0x08, 0xF9, 0x96, 0xE9,
	0x30, 0x4E, 0xA7, 0x3B, 0x31, 0x13, 0xB6, 0xEA, 0x00, 0xAC, 0xA3, 0x5E,
	0x34, 0x6F, 0x7D, 0x39, 0xF4, 0xEC, 0x45, 0xDE, 0xAA, 0xF6, 0xF7, 0x12,
	0x8E, 0xD4, 0x55, 0x42, 0x02, 0xBC, 0x3A, 0xE4, 0x7A, 0xA1, 0xB9, 0x01,
	0x15, 0x26, 0xBB, 0xB7,	0x78, 0xCA, 0x66, 0xED, 0xFF, 0x68, 0x43, 0xE8,
	0xDF, 0xAE, 0x17, 0x09, 0xE3, 0xFD, 0x5D, 0x51, 0x52, 0xC8, 0xF3, 0xF0,
	0x50, 0x2E, 0x9A, 0x29, 0x6D, 0x22, 0x87, 0x53,	0x2A, 0x95, 0x4F, 0x57,
	0xAB, 0x90, 0x73, 0xB0, 0x49, 0x0F, 0x83, 0xA0, 0x4A, 0x63, 0x38, 0x72,
	0xD8, 0x98, 0x84, 0x82
};
	
unsigned char table_5[256] =
{
	0xB0, 0xCB, 0xC4, 0x67, 0x2F, 0x7C, 0x70, 0x6E, 0xA4, 0xDB, 0x3A, 0x54,
	0x58, 0x2C, 0x23, 0xF5, 0x0A, 0x15, 0xBF, 0xAD, 0x26, 0xCC, 0x90, 0xDA,
	0x9A, 0x04, 0x64, 0x82,	0x56, 0x44, 0x0D, 0x61, 0x76, 0x18, 0xE9, 0x7B,
	0x8A, 0x14, 0xCD, 0x42, 0x65, 0xE7, 0xEC, 0x32, 0x20, 0x30, 0xE5, 0x1F,
	0xA8, 0xAC, 0x13, 0x85, 0xB4, 0x5B, 0x24, 0x88,	0xFA, 0xB7, 0xC6, 0xAB,
	0x07, 0x78, 0x9B, 0x75, 0x68, 0x0F, 0xC3, 0xD6, 0x84, 0xBA, 0x91, 0x09, 
	0x73, 0xF4, 0xF8, 0x06, 0x5C, 0x33, 0xA9, 0xEE, 0xE4, 0xDF, 0xE0, 0xEB,
	0x19, 0xC2, 0x34, 0xEF, 0x1D, 0x51, 0x80, 0x7A, 0x31, 0xDE, 0xB3, 0x1C,
	0x9D, 0x63, 0x8E, 0xF9, 0x6F, 0x45, 0xD2, 0x72, 0xD5, 0x6D, 0x50, 0x94,
	0x3D, 0xE8, 0x62, 0xB5,	0x28, 0x39, 0xFB, 0xF2, 0x53, 0x55, 0x0E, 0x6C,
	0xD0, 0xA0, 0xC8, 0x35, 0x93, 0xB6, 0x8B, 0x2E, 0x03, 0x87, 0xFF, 0xF6,
	0xFE, 0x7D, 0x25, 0xEA, 0x5F, 0x29, 0x8C, 0x49,	0xA3, 0x7F, 0xC0, 0x60,
	0xF1, 0x97, 0x1A, 0x71, 0x48, 0xED, 0xA6, 0x2A, 0xFD, 0x9C, 0xE6, 0x3E,
	0xA1, 0x36, 0x52, 0x86, 0xF7, 0xC9, 0x10, 0xB2, 0x79, 0x96, 0x0C, 0xAA,
	0x8D, 0xA2, 0xBC, 0xF0, 0xB1, 0x3F, 0xD9, 0x43, 0xF3, 0x22, 0x7E, 0x3C,
	0x5D, 0x5E, 0xAE, 0xCF, 0x38, 0xCA, 0x4E, 0xCE, 0xC5, 0x92, 0x47, 0x3B,
	0x4B, 0x1E, 0x40, 0x08,	0x9F, 0x1B, 0x11, 0x17, 0xE1, 0x4A, 0xD1, 0x99,
	0x4D, 0x83, 0x98, 0x8F, 0x74, 0x77, 0x21, 0x27, 0xC1, 0x59, 0x57, 0x00,
	0xFC, 0x2B, 0x9E, 0x16, 0x95, 0x4F, 0xBB, 0xD8,	0x02, 0x05, 0x0B, 0xDC,
	0xC7, 0x6A, 0x46, 0x66, 0xD7, 0xA7, 0xAF, 0x12, 0xB9, 0xD3, 0x69, 0x01,
	0xE3, 0x81, 0x37, 0xE2, 0xB8, 0x4C, 0xBD, 0xBE, 0x6B, 0xA5, 0x5A, 0x41,
	0x2D, 0xDD, 0x89, 0xD4
};

unsigned char table_6[256] =
{
	0x73, 0x48, 0x1B, 0x58, 0x1F, 0xCA, 0x18, 0x36, 0x8A, 0x6D, 0xD6, 0xB7,
	0x7B, 0x2C, 0x64, 0xDB, 0x0B, 0xAB, 0x94, 0x66, 0x5D, 0x12, 0x60, 0xA8,
	0x53, 0xEC, 0x61, 0x0C,	0x99, 0x55, 0xF9, 0x0F, 0xE2, 0xD4, 0xC6, 0x54,
	0x75, 0xF5, 0x4B, 0xAE, 0xB5, 0x59, 0x79, 0x19, 0x70, 0xC4, 0x4D, 0x33,
	0x22, 0x8F, 0xAC, 0xE9, 0x32, 0xEF, 0xF1, 0xE1, 0x02, 0xC9, 0xCD, 0x07,
	0xD5, 0xA6, 0x49, 0x4E, 0x69, 0xA5, 0x08, 0x8C, 0x6F, 0x92, 0xFB, 0x68,
	0xC7, 0x0A, 0xD3, 0x03, 0xD8, 0xC0, 0x41, 0x95, 0x9D, 0xBD, 0x74, 0xFC,
	0x62, 0x67, 0xB0, 0xA1, 0xD9, 0x7A, 0xBB, 0x2F, 0xA2, 0xDE, 0x28, 0x4C,
	0x46, 0xD0, 0x52, 0x00, 0xDD, 0x63, 0x4A, 0x3E, 0xE6, 0xF8, 0x25, 0xFA,
	0x3B, 0xC3, 0x44, 0xD2,	0xC5, 0x5B, 0xEE, 0x97, 0xCB, 0x21, 0xAA, 0x7C,
	0x5F, 0x3F, 0x2E, 0xEA, 0xF6, 0x77, 0xF3, 0x20, 0x96, 0xBF, 0xB8, 0x30,
	0xED, 0x5E, 0x56, 0x5C, 0x16, 0x1E, 0x93, 0x2A,	0x80, 0x43, 0x37, 0x34,
	0x15, 0x72, 0x65, 0x84, 0x78, 0xB6, 0x42, 0x47, 0x9C, 0x35, 0x06, 0x83,
	0x13, 0x57, 0xCC, 0x87, 0xB1, 0xBA, 0x26, 0x6B, 0x2B, 0x6C, 0xB9, 0x81,
	0x3D, 0xA7, 0x11, 0x76, 0xC2, 0x01, 0x45, 0x85, 0x1D, 0x7F, 0xF2, 0xE0,
	0xE7, 0x2D, 0x5A, 0xC1, 0xFF, 0x98, 0xB3, 0x91, 0x14, 0x9E, 0xF4, 0x10,
	0x88, 0xAD, 0x90, 0xCE, 0x8E, 0xDC, 0xE4, 0x6E, 0xD7, 0xF7, 0xA9, 0x05,
	0x09, 0xA3, 0x39, 0x3A, 0xC8, 0xCF, 0x8D, 0x1A, 0x6A, 0x86, 0x9B, 0xF0,
	0x29, 0x38, 0x4F, 0xA4, 0x7E, 0x31, 0x0E, 0x0D, 0x3C, 0xE8, 0xB4, 0xA0,
	0xAF, 0xE5, 0xFD, 0x50, 0xEB, 0x40, 0x9F, 0xDA, 0x7D, 0x82, 0xDF, 0xB2,
	0x27, 0x71, 0x04, 0xBC, 0xE3, 0x8B, 0x24, 0x51, 0xD1, 0x89, 0x23, 0xBE,
	0x9A, 0x1C, 0x17, 0xFE
};

unsigned char table_7[256] =
{
	0x63, 0xAD, 0x38, 0x4B, 0xF2, 0xCB, 0x9A, 0x3B, 0x42, 0xCC, 0x49, 0x10,
	0x1B, 0xDF, 0xDE, 0x1F, 0xBF, 0xAA, 0x15, 0x9C, 0xBC, 0x90, 0x88, 0xFE,
	0x06, 0x2B, 0xD3, 0x02,	0xFD, 0xB0, 0x89, 0x04, 0x7F, 0x75, 0x30, 0xFA,
	0xF6, 0x6A, 0xA2, 0xF0, 0x5E, 0xD8, 0x8B, 0xA4, 0x0D, 0xB5, 0x7A, 0x5B,
	0x83, 0xDD, 0x34, 0x2F, 0x8F, 0x99, 0x07, 0x8E, 0xD9, 0xCE, 0xCF, 0x6C,
	0xE0, 0xA8, 0x67, 0x79, 0xE9, 0x4E, 0x96, 0x8D, 0x6E, 0xAE, 0x60, 0x97,
	0x01, 0x3E, 0x66, 0x26, 0x5F, 0x2E, 0x3F, 0xDA, 0xE7, 0xF7, 0x62, 0x18,
	0x23, 0x1D, 0x86, 0x9D, 0x03, 0x29, 0xB6, 0x71, 0x87, 0x14, 0x85, 0x78,
	0x16, 0x1A, 0x54, 0x65, 0x0E, 0x92, 0x13, 0x55, 0x47, 0x40, 0xD4, 0xA3,
	0xA5, 0x09, 0xC7, 0x44, 0x2C, 0xF1, 0x91, 0x00, 0x52, 0x24, 0xAB, 0x7D,
	0x94, 0x2A, 0x59, 0x0C, 0x77, 0xEC, 0xDC, 0xB1, 0x8C, 0xA7, 0xED, 0x9B,
	0x93, 0xAF, 0xD5, 0x9F, 0xC0, 0xF9, 0x08, 0xF5, 0x43, 0xD2, 0xC4, 0x31,
	0xC2, 0xBB, 0x45, 0x8A, 0x12, 0x4F, 0x80, 0x73, 0xB9, 0x1C, 0xFC, 0xD6,
	0x98, 0x50, 0xBD, 0xEA, 0xE3, 0x57, 0x5C, 0xCD, 0xDB, 0x41, 0x3D, 0xA9,
	0x17, 0xCA, 0x76, 0x11, 0x32, 0xC1, 0x27, 0xE4, 0x56, 0xA0, 0xEF, 0xBA,
	0xE2, 0x28, 0x95, 0x0B,	0x82, 0xA6, 0xA1, 0x5A, 0xF3, 0x51, 0xFB, 0x81,
	0x4D, 0xB7, 0xAC, 0x6D, 0x2D, 0x70, 0x22, 0x48, 0xD0, 0x39, 0x05, 0x74,
	0x9E, 0x3A, 0xC3, 0xD1, 0x61, 0xF8, 0x6F, 0x4A,	0x21, 0x3C, 0x0A, 0xC8,
	0x4C, 0x58, 0xEB, 0x0F, 0xC5, 0x64, 0x5D, 0xEE, 0xB3, 0x37, 0x20, 0xF4,
	0xC6, 0xE5, 0x68, 0xB4, 0xE1, 0x33, 0x7B, 0xE8, 0x19, 0x84, 0x72, 0x35,
	0xD7, 0x36, 0xB2, 0x7E, 0xBE, 0x25, 0x7C, 0xC9, 0x69, 0x1E, 0x6B, 0x46,
	0x53, 0xE6, 0xFF, 0xB8
};

/*****************************************************************************/

static as_uint16 munge (as_uint8 *data, int len, as_uint16 key,
                        as_uint16 mul, as_uint16 add)
{
	int i;

	for (i = 0; i < len; i++)
	{
		data[i] = data[i] ^ (key >> 8);
		key = (key + data[i]) * mul + add;
	}

	return key;
}

static as_uint16 unmunge (as_uint8 *data, int len, as_uint16 key,
                          as_uint16 mul, as_uint16 add)
{
	as_uint8 c;
	int i;

	for (i = 0; i < len; i++)
	{
		c = data[i] ^ (key >> 8);
		key = (key + data[i]) * mul + add;
		data[i] = c;
	}

	return key;
}

/*****************************************************************************/

static as_uint16 calc_packet_key (as_uint8 packet_seed, as_uint16 seed_16,
                                  as_uint8 seed_8)
{
	unsigned int ps = (unsigned int)packet_seed;
	unsigned int table_state;
	int i;

	table_state = (unsigned int) table_1[seed_8];

	for (i = 0; i < 4; i++)
	{
		table_state -= ps * 3;    /* CHECKME: what if ps * 3 > table_state? */
		table_state += table_2[ps] - table_3[ps];
		table_state += seed_16;
	}

	return (table_state & 0xFFFF);
}

/* A slightly modified version of the algo used for search token hashing.
 * Used in several places.
 */
static as_uint16 hash_lowered_token (as_uint8 *str, int len)
{
	as_uint32 acc = 0;
	as_uint8 c;
	int b = 0;

	/* this is a very poor hash function :( */
	for (; len > 0; len--, str++)
	{
		c = tolower (*str);
		acc ^= c << (b * 8);
		b = (b + 1) & 3;
	}

	return (acc * 0x4f1bbcdc) >> 16;
}

/*****************************************************************************/

/* allocate and init cipher */
ASCipher *as_cipher_create (as_uint16 handshake_key)
{
	ASCipher *cipher;

	if (!(cipher = malloc (sizeof (ASCipher))))
		return NULL;

	cipher->handshake_key = handshake_key;
	cipher->session_seed_16 = 0;
	cipher->session_seed_8 = 0;

	return cipher;
}

/* free cipher */
void as_cipher_free (ASCipher *cipher)
{
	if (!cipher)
		return;

	free (cipher);
}

/* set seeds and calculate session key */
void as_cipher_set_seeds (ASCipher *cipher, as_uint16 seed_16,
                          as_uint8 seed_8)
{
	if (!cipher)
		return;

	cipher->session_seed_16 = seed_16;
	cipher->session_seed_8 = seed_8;
}

/*****************************************************************************/

/* encrypt/decrypt a block of data with session key */
void as_cipher_encrypt (ASCipher *cipher, as_uint8 packet_seed,
                        as_uint8 *data, int len)
{
	as_uint16 key;
	
	key = calc_packet_key (packet_seed, cipher->session_seed_16,
	                       cipher->session_seed_8);

	munge (data, len, key, 0xCE6D, 0x58BF);
}

void as_cipher_decrypt (ASCipher *cipher, as_uint8 packet_seed,
                        as_uint8 *data, int len)
{
	as_uint16 key;
	
	key = calc_packet_key (packet_seed, cipher->session_seed_16,
	                       cipher->session_seed_8);

	unmunge (data, len, key, 0xCE6D, 0x58BF);
}

/* Encrypt entire packet using cipher. This will add the two bytes of seed
 * to the beginning of the packet.
 */
as_bool as_cipher_encrypt_packet (ASCipher *cipher, ASPacket *packet)
{
	as_uint8 seed_a = 0x00; /* always use zero for out packet seeds */
	as_uint8 seed_b = 0x00;

	/* encrypt packet with choosen seeds */
	as_cipher_encrypt (cipher, seed_a, packet->data, as_packet_size (packet));

	/* make enough room for seeds */
	if (!as_packet_resize (packet, as_packet_size (packet) + 2))
		return FALSE;

	/* move data towards end by two bytes */
	memmove (packet->data + 2, packet->data, as_packet_size (packet));
	packet->used += 2;

	/* add seeds at front */
	packet->data[0] = seed_a;
	packet->data[1] = seed_b;

	return TRUE;
}

/* Decrypt entire packet using cipher. This will remove the two bytes of seed
 * at the beginning of the packet.
 */
as_bool as_cipher_decrypt_packet (ASCipher *cipher, ASPacket *packet)
{
	as_uint8 seed_a, seed_b;

	if (as_packet_remaining (packet) < 3)
		return FALSE;

	/* read packet seeds an remove them from packet */
	seed_a = as_packet_get_8 (packet);
	seed_b = as_packet_get_8 (packet);
	as_packet_truncate (packet);

	/* decrypt packet using first seed */
	as_cipher_decrypt (cipher, seed_a, packet->read_ptr,
	                   as_packet_remaining (packet));

	return TRUE;
}

/* encrypt/decrypt a block of data with handshake key */
void as_cipher_encrypt_handshake (ASCipher *cipher, as_uint8 *data, int len)
{
	munge (data, len, cipher->handshake_key, 0x5CA0, 0x15EC);
}

void as_cipher_decrypt_handshake (ASCipher *cipher, as_uint8 *data, int len)
{
	unmunge (data, len, cipher->handshake_key, 0x5CA0, 0x15EC);
}

/*****************************************************************************/

/* Calculate 22 byte nonce used in handshake from supernode GUID and session
 * seeds. Caller frees returned memory.
 */
as_uint8 *as_cipher_nonce (ASCipher *cipher, as_uint8 guid[16])
{
	as_uint16 key, token;
	as_uint8 *nonce;
	ASSHA1State sha1_state;
	as_uint8 buf[32];
	int i;

	if (!(nonce = malloc (sizeof (as_uint8) * 22)))
		return NULL;

	/* prepare GUID */
	memcpy (buf, guid, 16);

	buf[0] = (buf[1] ^ buf[11]) + 0x431F;

	for (i = 0; i < 16; i++)
		buf[i] ^= table_4[16 - 1 - i];
	
	memcpy (buf + 16, buf, 16);/* concat with self */

	for (i = 0; i < 32; i++)
		buf[i] ^= table_5[32 - 1 - i];

	for (i = 0; i < 32; i++)
		buf[i] ^= table_6[32 - 1 - i];

	for (i = 0; i < 32; i++)
		buf[i] ^= table_7[i + 1] + table_1[i + 1];

	/* hash it 16 times with special ares sha1 */
	as_sha1_ares_init (&sha1_state);
	for (i = 0; i < 16; i++)
		as_sha1_update (&sha1_state, buf, 32);
	as_sha1_final (&sha1_state, buf);

	/* hash this guid */
	token = hash_lowered_token (buf, 20);

	/* create key */
	key = calc_packet_key (cipher->session_seed_8, cipher->session_seed_16,
	                       cipher->session_seed_8);
	key++;

	/* prepend key and token */
	memmove (buf + 4, buf, 20);
	buf[0] = (key       ) & 0xFF;
	buf[1] = (key   >> 8) & 0xFF;
	buf[2] = (token     ) & 0xFF;
	buf[3] = (token >> 8) & 0xFF;

	buf[0] = 0xFF; /* whatever you say */

	/* sha1 it 32 times */
	as_sha1_init (&sha1_state);
	for (i = 0; i < 32; i++)
		as_sha1_update (&sha1_state, buf, 24);
	as_sha1_final (&sha1_state, nonce);

	/* append token of sha1 hash */
	token = hash_lowered_token (nonce, 20);
	nonce[20] = (token     ) & 0xFF;
	nonce[21] = (token >> 8) & 0xFF;

	return nonce;
}

/* Calculate 20 byte nonce used in handshake with Ares 2962 and later.
 * Requires supernode GUID from 0x38 packet. Caller frees returned memory.
 */
as_uint8 *as_cipher_nonce2 (as_uint8 guid[16])
{
	/*
	 * Pseudo code of what this does:
	 * 
	 * input: string guid
	 * vars: byte a = 128, byte b = 128, string nonce
	 *
	 * nonce = SHA1 (guid)
	 * while (length (nonce) < 512)
	 * {
	 *     nonce = nonce + SHA1 (byte_string (a) + nonce + byte_string (b));
	 *     a++;
	 *     b--;
	 * }
	 * truncate (nonce, 512)
	 * apply_boring_munging (nonce)
	 * nonce = SHA1 (nonce)
	 *	
	 */
	as_uint8 a = 128, b = 128;
	as_uint8 buf[512+20], *nonce;
	as_uint32 buf_len = 0;
	ASSHA1State sha1_state;

	/* Calc SHA1 of GUID. */
	as_sha1_init (&sha1_state);
	as_sha1_update (&sha1_state, guid, 16);
	as_sha1_final (&sha1_state, buf);
	buf_len = 20;

	/* Make 512 byte SHA1 concat */
	while (buf_len < 512)
	{
		/* Calc SHA1 (a + buf + b) and append to buffer. */
		as_sha1_init (&sha1_state);
		as_sha1_update (&sha1_state, &a, 1);
		as_sha1_update (&sha1_state, buf, buf_len);
		as_sha1_update (&sha1_state, &b, 1);
		as_sha1_final (&sha1_state, buf + buf_len);
		buf_len += 20;
		a++;
		b--;
	}

	/* Truncate buffer. */
	buf_len = 512;

	/* Munge buffer with boring code. */

	/* On 2005-09-15 the Ares source code was released at
	 * http://sourceforge.net/projects/aresgalaxy/ . The source no longer
	 * contains this encryption code and all supernodes should simply ignore
	 * the nonce from now on. We keep this code in case someone changes his
	 * mind again.
	 */
#if 0
#define INVOKE(func,buf) __asm lea eax, buf __asm call func
	INVOKE(sub_5F0FF4, buf);
	INVOKE(sub_5EFB14, buf);
	INVOKE(sub_5ECD08, buf);
	INVOKE(sub_5F1D64, buf);
	INVOKE(sub_5EEAD0, buf);
	INVOKE(sub_5F01D8, buf);
	INVOKE(sub_5F251C, buf);
	INVOKE(sub_5F0C40, buf);
	INVOKE(sub_5F2F54, buf);
	INVOKE(sub_5ED4C0, buf);
	INVOKE(sub_5F05C4, buf);
	INVOKE(sub_5F3744, buf);
	INVOKE(sub_5F45FC, buf);
	INVOKE(sub_5EC6A0, buf);
	INVOKE(sub_5F1878, buf);
	INVOKE(sub_5EDE08, buf);
	INVOKE(sub_5EE220, buf);
	INVOKE(sub_5EF3AC, buf);
	INVOKE(sub_5F3E8C, buf);
	INVOKE(sub_5F2828, buf);
#undef INVOKE
#endif

	/* Create nonce from buffer. */
	if (!(nonce = malloc (sizeof (as_uint8) * 20)))
		return NULL;

	as_sha1_init (&sha1_state);
	as_sha1_update (&sha1_state, buf, buf_len);
	as_sha1_final (&sha1_state, nonce);

	return nonce;
}

/*****************************************************************************/

/* Index nodes have their port derived from ip. Use this to calculate it. */
in_port_t as_ip2port (in_addr_t ip)
{
	as_uint8 ip_str[4];
	as_uint8 tmp_str[4];
	as_uint16 ip_token;
	as_uint32 port;

	/* Be portable */
	ip = ntohl (ip);

	ip_str[0] = (as_uint8) ((ip >> 24) & 0xFF);
	ip_str[1] = (as_uint8) ((ip >> 16) & 0xFF);
	ip_str[2] = (as_uint8) ((ip >> 8)  & 0xFF);
	ip_str[3] = (as_uint8) ((ip >> 0)  & 0xFF);

	ip_token = hash_lowered_token (ip_str, 4);

	port = (((((as_uint16) ip_str[0]) * ip_str[0]) + ip_token) * 3);

	tmp_str[0] = port & 0xFF;
	tmp_str[1] = (port >> 8) & 0xFF;
	tmp_str[2] = 0xBE;
	tmp_str[3] = 0x04;

	port += hash_lowered_token (tmp_str, 4);
	port += ip_token + 0x12;
	port += 0x5907;                                  /* hash of "strano" */
	port -= (((as_uint16) ip_str[0] - 5) << 2) * 3;
	port += 0xCDF8;                                  /* hash of "robboso" */

	if (port < 1024)
		port += 1024;

	if (port == 36278)
		port++;

	return (in_port_t) (port & 0xFFFF);
}

/*****************************************************************************/

/* encrypt/decrypt http download header b6st */
void as_encrypt_b6st (as_uint8 *data, int len)
{
	munge (data, len, 0xB334, 0xCE6D, 0x58BF);
}

void as_decrypt_b6st (as_uint8 *data, int len)
{
	unmunge (data, len, 0xB334, 0xCE6D, 0x58BF);
}

/* encrypt/decrypt http download header b6mi */
void as_encrypt_b6mi (as_uint8 *data, int len)
{
	munge (data, len, 0x0E21, 0xCB6F, 0x41BA);
}

void as_decrypt_b6mi (as_uint8 *data, int len)
{
	unmunge (data, len, 0x0E21, 0xCB6F, 0x41BA);
}

/* encrypt/decrypt push request */
void as_encrypt_push (as_uint8 *data, int len, in_addr_t host, in_port_t port)
{
	assert (len >= 6);

	/* Be portable */
	host = ntohl (host);

	munge (data+6, len-6, (as_uint16)(host & 0xFFFF), 0xCE6D, 0x58BF);
	munge (data+6, len-6, (as_uint16)(host >> 16), 0xCE6D, 0x58BF);
	munge (data+6, len-6, port, 0xCE6D, 0x58BF);
	munge (data+6, len-6, (as_uint16)(host & 0xFFFF), 0xCE6D, 0x58BF);
	munge (data+6, len-6, (as_uint16)(host >> 16), 0xCE6D, 0x58BF);
	munge (data+6, len-6, port, 0xCE6D, 0x58BF);
	munge (data, 6, 0x3E00, 0xCE6D, 0x58BF);
	munge (data, len, 0x4F54, 0xCE6D, 0x58BF);

/*
	munge (data+6, len-6, ((host & 0xff0000) >> 8) + (host >> 24), 0xCE6D, 0x58BF);
	munge (data+6, len-6, ((host & 0xff) << 8) + ((host & 0xff00) >> 8), 0xCE6D, 0x58BF);
	munge (data+6, len-6, port, 0xCE6D, 0x58BF);
	munge (data+6, len-6, ((host & 0xff0000) >> 8) + (host >> 24), 0xCE6D, 0x58BF);
	munge (data+6, len-6, ((host & 0xff) << 8) + ((host & 0xff00) >> 8), 0xCE6D, 0x58BF);
	munge (data+6, len-6, port, 0xCE6D, 0x58BF);
	munge (data, 6, 0x3E00, 0xCE6D, 0x58BF);
	munge (data, len, 0x4F54, 0xCE6D, 0x58BF);
*/
}	

void as_decrypt_push (as_uint8 *data, int len, in_addr_t host, in_port_t port)
{
	assert (len >= 6);

	/* Be portable */
	host = ntohl (host);

	unmunge (data, len, 0x4F54, 0xCE6D, 0x58BF);
	unmunge (data, 6, 0x3E00, 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, port, 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, (as_uint16)(host >> 16), 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, (as_uint16)(host & 0xFFFF), 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, port, 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, (as_uint16)(host >> 16), 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, (as_uint16)(host & 0xFFFF), 0xCE6D, 0x58BF);

/*
	unmunge (data, len, 0x4F54, 0xCE6D, 0x58BF);
	unmunge (data, 6, 0x3E00, 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, port, 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, ((host & 0xff) << 8) + ((host & 0xff00) >> 8), 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, ((host & 0xff0000) >> 8) + (host >> 24), 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, port, 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, ((host & 0xff) << 8) + ((host & 0xff00) >> 8), 0xCE6D, 0x58BF);
	unmunge (data+6, len-6, ((host & 0xff0000) >> 8) + (host >> 24), 0xCE6D, 0x58BF);
*/
}
  
/* encrypt/decrypt arlnk URLs */
void as_encrypt_arlnk (as_uint8 *data, int len)
{
	munge (data, len, 0x6F13, 0x5AB3, 0x8D1E);
}

void as_decrypt_arlnk (as_uint8 *data, int len)
{
	unmunge (data, len, 0x6F13, 0x5AB3, 0x8D1E);
}

/* encrypt/decrypt login string */
void as_encrypt_login_string (as_uint8 *data, int len, as_uint16 seed_16,
                              as_uint8 seed_8)
{
	munge (data, len, seed_16 + 0x0C, 0xCE6D, 0x58BF);
	munge (data, len, (seed_16 - seed_8) + 0x0B, 0x310F, 0x3A4E);
}

void as_decrypt_login_string (as_uint8 *data, int len, as_uint16 seed_16,
                              as_uint8 seed_8)
{
	unmunge (data, len, (seed_16 - seed_8) + 0x0B, 0x310F, 0x3A4E);
	unmunge (data, len, seed_16 + 0x0C, 0xCE6D, 0x58BF);
}

/*****************************************************************************/

/* encrypt/decrypt binary transfer requests */
as_bool as_encrypt_transfer_0a (ASPacket *packet)
{
	as_uint16 payload_len = as_packet_size (packet);
	/* Ares uses milliseconds since system start for ticks. Simulate a
	 * reasonable value (1-6 hours) */
	as_uint32 ticks = 3600000 + (as_uint32)(18000000.0*rand()/(RAND_MAX+1.0));
	as_uint16 ticks_hash;

	/* make enough room for header */
	if (!as_packet_resize (packet, payload_len + 9))
		return FALSE;

	/* move data towards end by 9 bytes */
	memmove (packet->data + 9, packet->data, payload_len);
	packet->used += 9;

	/* add header */
	packet->data[0] = rand () % 0x100;
	packet->data[1] = ticks & 0xFF;          /* little endian */
	packet->data[2] = (ticks >> 8) & 0xFF;
	packet->data[3] = (ticks >> 16) & 0xFF;
	packet->data[4] = (ticks >> 24) & 0xFF;
	packet->data[5] = 0x00; /* hardcoded in Ares */
	packet->data[6] = rand () % 0x100;

	ticks_hash = hash_lowered_token (packet->data + 1, 4) + 0x15;
	packet->data[7] = ticks_hash & 0xFF; /* littel endian */
	packet->data[8] = ticks_hash >> 8;

	/* munge payload */
	munge (packet->data + 9, payload_len, 0xb334, 0xce6d, 0x58bf);

	/* munge entire packet */
	munge (packet->data, packet->used, 0x15d9, 0x5ab3, 0x8d1e);
	munge (packet->data, packet->used, 0x5f40, 0x310f, 0x3a4e);

	return TRUE;
}

as_bool as_decrypt_transfer_0a (ASPacket *packet)
{
	as_uint32 ticks;
	as_uint16 ticks_hash;

	/* remove stuff which may lead us in packet */
	as_packet_truncate (packet);

	/* unmunge entire packet */
	unmunge (packet->data, packet->used, 0x5f40, 0x310f, 0x3a4e);
	unmunge (packet->data, packet->used, 0x15d9, 0x5ab3, 0x8d1e);

	if (as_packet_remaining (packet) < 9)
		return FALSE;

	/* read header */
	as_packet_get_8 (packet); /* random */
	ticks = as_packet_get_le32 (packet);
	as_packet_get_8 (packet); /* 0x00 */
	as_packet_get_8 (packet); /* random */
	ticks_hash = as_packet_get_le16 (packet);

	/* TODO: check if ticks_hash is correct? */

	/* remove header */
	as_packet_truncate (packet);

	/* unmunge payload */
	unmunge (packet->data, packet->used, 0xb334, 0xce6d, 0x58bf);

	return TRUE;
}

as_bool as_encrypt_transfer_request (ASPacket *packet)
{
	as_uint8 i;
	as_uint8 skip = 1 + (rand () % 16); /* Ares does 1 + (rand() % 16) */
	as_uint16 payload_len = as_packet_size (packet);

	/* make enough room for header */
	if (!as_packet_resize (packet, payload_len + 5 + skip))
		return FALSE;

	/* move data towards end by 3 + skip + 2 bytes */
	memmove (packet->data + 5 + skip, packet->data, payload_len);
	packet->used += 5 + skip;

	/* add header */
	packet->data[0] = rand () % 0x100;
	packet->data[1] = rand () % 0x100;
	packet->data[2] = skip;
	for (i = 0; i < skip; i++)
		packet->data[3 + i] = rand () % 0x100;

	packet->data[3 + skip + 0] = payload_len & 0xFF; /* little endian */
	packet->data[3 + skip + 1] = payload_len >> 8;

	/* munge payload */
	munge (packet->data + 5 + skip, payload_len, 0x3faa, 0xd7fb, 0x3efd);

	/* munge entire packet */
	munge (packet->data, packet->used, 0x5d1c, 0x5ca0, 0x15ec);

	return TRUE;
}

as_bool as_decrypt_transfer_request (ASPacket *packet)
{
	as_uint8 i, skip;
	as_uint16 payload_len;

	/* remove stuff which may lead us in packet */
	as_packet_truncate (packet);

	/* unmunge entire packet */
	unmunge (packet->data, packet->used, 0x5d1c, 0x5ca0, 0x15ec);

	if (as_packet_remaining (packet) < 6)
		return FALSE;

	/* read header */
	as_packet_get_le16 (packet); /* random */
	skip = as_packet_get_8 (packet);

	if (as_packet_remaining (packet) < skip + 2)
		return FALSE;

	for (i = 0; i < skip; i++)
		as_packet_get_8 (packet); /* random */

	payload_len = as_packet_get_le16 (packet);

	if (as_packet_remaining (packet) < payload_len)
		return FALSE;

	/* remove header */
	as_packet_truncate (packet);

	/* unmunge payload */
	unmunge (packet->data, packet->used, 0x3faa, 0xd7fb, 0x3efd);

	return TRUE;
}

/* encrypt/decrypt transfer replies. Updates key. */
as_bool as_encrypt_transfer_reply (ASPacket *packet, as_uint16 *key)
{
	as_uint8 i;
	as_uint8 skip = 1 + (rand () % 16); /* Ares does 1 + (rand() % 16) */
	as_uint16 payload_len = as_packet_size (packet);

	/* make enough room for header */
	if (!as_packet_resize (packet, payload_len + 3 + skip))
		return FALSE;

	/* move data towards end by 3 + skip */
	memmove (packet->data + 3 + skip, packet->data, payload_len);
	packet->used += 3 + skip;

	/* add header */
	packet->data[0] = rand () % 0x100;
	packet->data[1] = rand () % 0x100;
	packet->data[2] = skip;
	for (i = 0; i < skip; i++)
		packet->data[3 + i] = rand () % 0x100;

	/* munge entire packet */
	*key = munge (packet->data, packet->used, *key, 0xCB6F, 0x41BA);

	return TRUE;
}

as_bool as_decrypt_transfer_reply (ASPacket *packet, as_uint16 *key)
{
	int i;
	int skip;

	/* remove stuff which may lead us in packet */
	as_packet_truncate (packet);

	/* unmunge entire packet */
	*key = unmunge (packet->data, packet->used, *key, 0xCB6F, 0x41BA);

	if (as_packet_remaining (packet) < 3)
		return FALSE;

	/* read header */
	as_packet_get_le16 (packet); /* random */
	skip = as_packet_get_8 (packet);

	if (as_packet_remaining (packet) < skip)
		return FALSE;

	for (i = 0; i < skip; i++)
		as_packet_get_8 (packet); /* random */

	/* http header follows, remove binary header */
	as_packet_truncate (packet);

	return TRUE;
}

/* encrypt/decrypt transfer body. Updates key. */
void as_encrypt_transfer_body (as_uint8 *data, int len, as_uint16 *key)
{
	*key = munge (data, len, *key, 0xCB6F, 0x41BA);
}

void as_decrypt_transfer_body (as_uint8 *data, int len, as_uint16 *key)
{
	*key = unmunge (data, len, *key, 0xCB6F, 0x41BA);
}

/*****************************************************************************/

#if 0
int main(int argc, char *argv[])
{
	ASPacket *p = as_packet_slurp();
	in_addr_t host = net_ip (argv[1]);
	in_port_t port = atoi (argv[2]);

	printf ("%s (%x):%d\n", net_ip_str(host), host, port);
	printf ("%x %x\n", 
		((host & 0xff) << 8) + ((host & 0xff00) >> 8),
		((host & 0xff0000) >> 8) + (host >> 24)
		);

	as_decrypt_push (p->data, p->used, host, port);
	as_packet_dump (p);
	as_packet_free (p);

	return 0;
}
#endif
