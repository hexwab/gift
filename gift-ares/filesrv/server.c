/*
 * $Id: server.c,v 1.2 2005/11/19 13:53:23 mkern Exp $
 *
 * Copyright (C) 2005 Markus Kern <mkern@users.berlios.de>
 * Copyright (C) 2005 Tom Hargreaves <hex@freezone.co.uk>
 *
 * All rights reserved.
 */

#include <signal.h>
#include "as_ares.h"
#include "server.h"

/*****************************************************************************/

/*
 * Loads plain text shares file generated by asfilehasher and uploads files
 * to Ares clients. The shares file is reloaded and all previous shares are
 * removed when the daemon receives the HUP signal.
 */

/*****************************************************************************/

/* signal handlers */
static void sighup_handler (int sig_num);
static void sigint_handler (int sig_num);
static void sigterm_handler (int sig_num);

/* Periodic timer which handles signals in event loop */
static as_bool signal_timer_func (void *data);

/* loads shares from file into shares manager */
static as_bool load_shares (char *shares_file);

/*****************************************************************************/

static char *shares_file = NULL;
static as_bool sighup_reload_shares = FALSE; /* set to TRUE by SIGHUP and
                                              * checked by timer in event
                                              * loop. */
static as_bool signal_quit = FALSE;          /* set to TRUE by SIGINT or
                                              * SITERM and checked yb timer
                                              * in event loop. */

/*****************************************************************************/

int main (int argc, char *argv[])
{
	ASLogger *logger;
	in_port_t listen_port = 0;
	timer_id signal_timer;
	int max_uploads;
	as_bool daemon = FALSE;
	
	if (argc != 4 && argc != 5)
	{
		printf ("Usage: asfileserver <shares file> <listen port> <max uploads> [-d]\n");
		printf ("Reads shares file and provides shares to Ares clients on listen port.\n");
		printf ("If -d is supplied we fork to background.\n");
		printf ("The shares file is reloaded on HUP.\n");
		exit (1);
	}

	shares_file = argv[1];

	if ((listen_port = atol (argv[2])) == 0)
	{
		printf ("Invalid listen port '%s'\n", argv[2]);
		exit (1);
	}

	if ((max_uploads = atoi (argv[3])) <= 0)
	{
		printf ("Invalid number of max uploads '%s'\n", argv[3]);
		exit (1);
	}

	if (argc == 5)
		daemon = (strcmp (argv[4], "-d") == 0);

	/* setup logging */
	logger = as_logger_create ();
	as_logger_add_output (logger, "stdout");
	as_logger_add_output (logger, "asfileserver.log");

	AS_DBG ("SERVER: Logging subsystem started");

	/* setup event system */
	as_event_init ();

	/* init lib */
	if (!as_init ())
	{
		printf ("FATAL: as_init () failed\n");
		exit (1);
	}

	if (!as_config_set_int (AS_CONF, AS_UPLOAD_MAX_ACTIVE, max_uploads))
	{
		printf ("FATAL: Failed to set AS_UPLOAD_MAX_ACTIVE to %u\n", max_uploads);
		exit (1);
	}

	/* set listening port */
	if (!as_config_set_int (AS_CONF, AS_LISTEN_PORT, listen_port))
	{
		printf ("FATAL: Failed to set listen port to %u\n", listen_port);
		exit (1);
	}

	/* load shares */
	if (!load_shares (shares_file))
	{
		printf ("FATAL: load_shares () failed\n");
		exit (1);
	}

	/* set handler for SIGHUP which reloads shares file */
    if (signal (SIGHUP, sighup_handler) == SIG_ERR)
		AS_WARN ("SERVER: Couldn't set SIGHUP handler");

	/* set handlers for SIGINT and SIGTERM */
    if (signal (SIGINT, sigint_handler) == SIG_ERR)
		AS_WARN ("SERVER: Couldn't set SIGINT handler");

    if (signal (SIGTERM, sigterm_handler) == SIG_ERR)
		AS_WARN ("SERVER: Couldn't set SIGTERM handler");

	/* add timer which checks for signals */
	if ((signal_timer = timer_add (5*SECONDS, signal_timer_func, NULL)) == INVALID_TIMER)
		AS_WARN ("SERVER: Couldn't install signal timer");

	/* fork to background if requested */
	if (daemon)
	{
		pid_t pid;

		if ((pid = fork ()) != 0)
		{
			AS_DBG_1 ("SERVER: Forked to background. pid: %u", pid);
			exit (0);
		}

		/* don't log to stdout anymore */
		as_logger_del_output (logger, "stdout");

		setsid ();

		close (STDIN_FILENO);
		close (STDOUT_FILENO);
		close (STDERR_FILENO);
	}

	/* run event loop */
	AS_DBG ("SERVER: Entering event loop");
	as_event_loop ();
	AS_DBG ("SERVER: Left event loop");

	/* remove signal handler and timer */
	timer_remove (signal_timer);
    signal (SIGHUP, SIG_DFL);
    signal (SIGINT, SIG_DFL);
    signal (SIGTERM, SIG_DFL);

	/* cleanup  lib */
	as_cleanup ();

	/* shutdown */
	as_event_shutdown ();
	as_logger_free (logger);

	return 0;
}

static void sighup_handler (int sig_num)
{
	assert (sig_num == SIGHUP);

    /* Re-set handler for next time. */
    signal (SIGHUP, sighup_handler);

	/* Tell event loop about this signal */
	sighup_reload_shares = TRUE;
}

static void sigint_handler (int sig_num)
{
	assert (sig_num == SIGINT);

    /* Re-set handler for next time. */
    signal (SIGINT, sigint_handler);

	/* Tell event loop about this signal */
	signal_quit = TRUE;
}

static void sigterm_handler (int sig_num)
{
	assert (sig_num == SIGTERM);

    /* Re-set handler for next time. */
    signal (SIGTERM, sigterm_handler);

	/* Tell event loop about this signal */
	signal_quit = TRUE;
}

/* Periodic timer which reloads shares file if SIGHUP happened and quits on
 * SIGTERM or SIGINT.  */
static as_bool signal_timer_func (void *data)
{
	if (sighup_reload_shares)
	{
		AS_DBG ("SERVER: Timer detected SIGHUP");
		
		if (!load_shares (shares_file))
		{
			AS_ERR_1 ("SERVER: Failed to reload shares file '%s' on SIGHUP",
			          shares_file);
		}
		
		sighup_reload_shares = FALSE;
	}

	if (signal_quit)
	{
		AS_DBG ("SERVER: Timer detected SIGINT or SIGTERM");
		signal_quit = FALSE;
		as_event_quit ();
	}

	return TRUE; /* trigger us again */
}

/*****************************************************************************/

/* loads shares from file into shares manager */
static as_bool load_shares (char *file)
{
	FILE *fp;
	char buf[1024*16];
	int nfiles;

	/* load shares */
	if (!(fp = fopen (file, "r")))
	{
		AS_ERR_1 ("SERVER: Failed to open shares file '%s'\n", file);
		return FALSE;
	}

	AS_DBG ("SERVER: Removing all shares");
	as_shareman_remove_all (AS->shareman);

	AS_DBG_1 ("SERVER: Reading shares from '%s'.", file);

	nfiles = 0;
	while (fgets (buf, sizeof (buf), fp))
	{
		char hash64[AS_HASH_BASE64_SIZE];
		char path[PATH_MAX];
		size_t size;
		time_t last_modify;
		ASHash *hash;
		ASShare *share;
		ASRealm realm;

		if (strlen (buf) >= sizeof (buf) - 1)
		{
			AS_ERR ("SERVER: Aborting share load. Line too long.");
			break;
		}

		/* <hash> <size> <last_modify> <path> */
		if (sscanf (buf, "%29s %u %lu %[^\r\n]", hash64, &size, &last_modify, path) != 4)
		{
			AS_ERR ("SERVER: sscanf failed for share.");
			continue;
		}

		/* Ares never shares unknown files. */
		if ((realm = as_meta_realm_from_filename (path)) == REALM_UNKNOWN)
		{
			AS_WARN_1 ("SERVER: Not sharing '%s' because its realm is unknown.", path);
			continue;
		}

		if (!(hash = as_hash_decode (hash64)))
		{
			AS_ERR ("SERVER: Failed to create hash for share.");
			continue;
		}

		if (!(share = as_share_create (path, hash, NULL, size, realm)))
		{
			AS_ERR ("SERVER: Failed to create share object.");
			as_hash_free (hash);
			continue;
		}

		if (!as_shareman_add (AS->shareman, share))
		{
			AS_ERR_1 ("SERVER: Failed to add share '%s' to share manager. Duplicate hash?", path);
			as_share_free (share);
			continue;
		}

		nfiles++;
	}

	fclose (fp);
	AS_DBG_1 ("SERVER: Loaded %d shares.", nfiles);	

	return TRUE;
}

/*****************************************************************************/
