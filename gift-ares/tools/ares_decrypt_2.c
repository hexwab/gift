/*
 * $Id: ares_decrypt_2.c,v 1.4 2005/12/17 23:09:58 mkern Exp $
 *
 * Copyright (C) 2003 giFT-Ares project
 * http://developer.berlios.de/projects/gift-ares
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */

#include <stdio.h>
#include <stdlib.h>
#include <zlib.h>

#define MAX_PACKET_SIZE (1024*16)

#define FATAL_ERROR(x) { fprintf (stderr, "\nFATAL: %s\n", x); exit (1); }

unsigned short table_1[256] =
{
	0x0000, 0x0808, 0xDC6C, 0x33DC, 0x45DD, 0xABF0, 0x5195, 0x296B, 0x5F4A,
	0x6CF8, 0x14FE, 0x798B, 0x1210, 0xD741, 0x0F4A, 0x4B15, 0xEAD2, 0x5E2E,
	0xC64F, 0x53F2, 0xB29A, 0xD81A, 0xB7CD, 0x4E7F, 0x29A1, 0x5459, 0x774C,
	0x3F24, 0xD35E, 0x476E, 0x7B54, 0x2630, 0xDFD3, 0x498B, 0xC5D2, 0xF9F8,
	0x7E15, 0xE34E, 0xD3C7, 0x0532, 0x241C, 0x24BC, 0x8034, 0x058C, 0x97C9,
	0x0278, 0xC643, 0xA690, 0xC53D, 0xB545, 0x8EB8, 0x34BE, 0xAE5A, 0x97C4,
	0xF497, 0xA4E0, 0xFF94, 0x3E68, 0xAD18, 0x4BB2, 0x15FC, 0xC5B6, 0x7ECA,
	0xE1B5, 0x828C, 0x92C4, 0xF403, 0xAF50, 0x56B5, 0x01F2, 0xB491, 0xFD2A,
	0xC627, 0xBFE3, 0x329C, 0x24C5, 0xE9E0, 0xC8C0, 0x96DA, 0xDD5C, 0xB079,
	0x49AF, 0x17F8, 0xA100, 0x47AF, 0xE08E, 0x2946, 0x45EF, 0x8B2E, 0xF5F5,
	0x2CA2, 0x2835, 0x44A3, 0x2D6D, 0x93A8, 0x7F86, 0x4901, 0x27EB, 0x9C18,
	0xBD5B, 0xBF13, 0x1491, 0x138A, 0x0F4D, 0x1B45, 0xCBA6, 0xCE4D, 0x61B0,
	0x9CAD, 0x6FD3, 0xBDA6, 0x7E71, 0x575E, 0xD1A1, 0xD128, 0x2432, 0x17EF,
	0x1131, 0x0F6F, 0x31A4, 0xAC46, 0x3A3B, 0x9202, 0x4125, 0x5DAB, 0xD64A,
	0x5087, 0x509B, 0xA80A, 0xB137, 0xE729, 0x5192, 0x7A8A, 0x4BE5, 0xC448,
	0xBD92, 0x8D4D, 0xB93C, 0x6961, 0x8AC3, 0x9887, 0xE169, 0xAB3E, 0x1CC5,
	0x78C2, 0x6755, 0x1D60, 0x0DCB, 0x8C71, 0xAC64, 0x14AA, 0xEBF6, 0xD6B4,
	0xAE70, 0xED4F, 0x46FA, 0xB36C, 0xBC06, 0x7FFF, 0xA9EC, 0x2881, 0x3AE1,
	0xF24E, 0x5D6B, 0x206F, 0xFCA5, 0x4E66, 0x0DF1, 0x1A18, 0xDDDE, 0x8DEF,
	0xB278, 0x19C6, 0xAB39, 0x043C, 0x4F51, 0xE77F, 0x8903, 0x53B8, 0x7142,
	0xE68F, 0x58E0, 0x5A90, 0x7CE0, 0x1251, 0xD9CD, 0xC2A2, 0x2E2D, 0xEC3E,
	0x7E59, 0x20A8, 0xE471, 0x673A, 0x3521, 0xCE9E, 0x965F, 0x1C1C, 0x9F8A,
	0xED7A, 0x8A62, 0x537C, 0x72C4, 0x3A0E, 0x2F46, 0xB0C2, 0xFEFC, 0xA136,
	0xB10D, 0x8A6C, 0x18E2, 0xBF47, 0x2611, 0x3BA1, 0xE15C, 0xB6B9, 0x7057,
	0xFAF3, 0x278A, 0x0A14, 0x2F34, 0x027B, 0x60FA, 0x6519, 0x5D23, 0x1511,
	0x742E, 0x8133, 0x75E6, 0xACE8, 0xD14C, 0x911E, 0x40DD, 0x5F53, 0x9525,
	0xDFD7, 0x9BA4, 0x41D4, 0xB26A, 0x8EC5, 0xE0F2, 0x5C62, 0x5D2B, 0x9F26,
	0xC7AE, 0x74FD, 0x3491, 0xB2BD, 0xD653, 0xC075, 0xE6DD, 0x2FBB, 0xC688,
	0x4478, 0x4BA2, 0xB3EB, 0x74F9
};

unsigned short table_2[256] = 
{
	0xCBA6, 0x1C3E, 0x60AE, 0x384F, 0x6800, 0xB1B7, 0x946F, 0xCDCB, 0xFCB6,
	0xE274, 0xDBB8, 0x50F5, 0x95FC, 0x3EDB, 0x69BA, 0x67B5, 0x6F11, 0xA3A4,
	0xD43D, 0x1DE6, 0x1DE5, 0x83E6, 0xB5DD, 0x007C, 0xCAED, 0x705E, 0x8280,
	0x33F2, 0x5144, 0x27FF, 0x0A1C, 0xF1F7, 0x6304, 0xBDC1, 0x65A9, 0x1A59,
	0x0DE4, 0x9FA3, 0x4A61, 0xC332, 0x3C13, 0x8B03, 0xFF40, 0xF453, 0x0D55,
	0xBA20, 0x70BA, 0xF9EF, 0x245D, 0xD6ED, 0x1EB7, 0xFA8A, 0x446B, 0x7F1A,
	0xE0D5, 0xBC22, 0xDB27, 0x655E, 0xBCDF, 0xC49D, 0x52BD, 0x5C07, 0x4B89,
	0x4173, 0x483B, 0xD4C6, 0x676F, 0x629D, 0x0229, 0xA1B5, 0x224E, 0x14BE,
	0xC368, 0x03AA, 0x3C83, 0x4691, 0xD64D, 0x51C1, 0x9AC2, 0x2594, 0x6BFE,
	0xC624, 0x7618, 0xFDF4, 0xAC0D, 0x3C1F, 0x4224, 0xA9B9, 0x9055, 0xEB62,
	0x8593, 0xBB34, 0x6912, 0x6C97, 0x20DB, 0xCEA6, 0x2545, 0x9325, 0xBF39,
	0xAF33, 0xBB47, 0xE843, 0x6DEE, 0x3B07, 0x4DAD, 0xD342, 0x95B6, 0x32C7,
	0xE85C, 0xBB14, 0xD28B, 0x603C, 0xF1EE, 0xAD22, 0x6599, 0xC03C, 0xAD45,
	0x554D, 0x3D82, 0x9BDA, 0x676F, 0x5343, 0xD0D4, 0xBCCF, 0x2DBA, 0x3905,
	0x46C9, 0x2928, 0x2818, 0xBEB6, 0xAA3F, 0x1232, 0xF3B7, 0xF7A7, 0x22F8,
	0xE2A4, 0x99D9, 0x94A2, 0x7114, 0x980D, 0xFEFB, 0x7F74, 0x26CC, 0xD37E,
	0xE624, 0x5BBE, 0x5C71, 0x4D79, 0xE48A, 0xB8FD, 0xDAA6, 0x991A, 0xE16C,
	0x01D8, 0xF6DB, 0x6285, 0xFE2D, 0x74AB, 0x9E0B, 0x9491, 0x02AE, 0xB152, //
	0x49B8, 0x11B4, 0xA9EF, 0xA839, 0xDB24, 0xEC2F, 0x6AE6, 0xF6A2, 0x98D2,
	0x497B, 0x99A0, 0xFC36, 0xCA3E, 0x5CF4, 0xFC97, 0x35D0, 0xADD9, 0x25C5,
	0x3254, 0xA986, 0xC549, 0xDC14, 0x8346, 0x6FFA, 0xB3E0, 0x3970, 0xFBE3,
	0xA6E0, 0x2B5B, 0x0879, 0xEAFE, 0x58D1, 0xA2DD, 0xA7CF, 0x2068, 0x2650,
	0xD42B, 0x6C3E, 0x87CB, 0xBC1A, 0x3B2B, 0x0E28, 0xFBC4, 0x62B4, 0x1398,
	0x8E34, 0x6D41, 0x3330, 0x9109, 0x3D36, 0xBB1B, 0xBD40, 0x4D22, 0xD35F,
	0xD5F4, 0x2A7F, 0x281A, 0xC2A6, 0x0C54, 0x2AFD, 0x176E, 0x3077, 0x9B00,
	0x3709, 0x9EE5, 0x429C, 0xDD9B, 0xF244, 0xEFC5, 0xAB6A, 0xBB81, 0xBBE3,
	0xEA55, 0xA12D, 0x2CE0, 0xB845, 0x7D94, 0xACD6, 0xF419, 0xDFB7, 0x2138,
	0xFBE5, 0xE757, 0xDE84, 0x65EA, 0x2192, 0x666F, 0xD241, 0xD7C2, 0x7340,
	0xD8F8, 0x3058, 0xAEFF, 0x6C24
};

unsigned short table_3[256] = 
{
	0x777F, 0x99EF, 0x65B7, 0x999E, 0x016E, 0xA28B, 0x413A, 0x4A42, 0x3FC3,
	0xB8A8, 0x89C6, 0x7FA9, 0xEBEA, 0x95CD, 0x2330, 0xC1F1, 0xD721, 0xDBA7,
	0xAF08, 0x56DB, 0xB3D9, 0x72D4, 0x9695, 0x63B3, 0x6F4D, 0xBAF0, 0x2B0F,
	0x7E87, 0xB762, 0x97DE, 0x181D, 0xDA86, 0x88BF, 0xA859, 0xA490, 0x7BB6,
	0xE12E, 0x31BC, 0x7D5E, 0x1DDB, 0xF233, 0x8D10, 0x06E3, 0xBAA4, 0x6FEB,
	0x2154, 0x7054, 0xDB19, 0xD828, 0x3712, 0x0584, 0x2043, 0xCDCB, 0x311F,
	0x7ADC, 0xAF1B, 0xE463, 0xF6B3, 0x2F96, 0x6BB5, 0x7805, 0x9AAB, 0xA23B,
	0x2FAE, 0x6D6B, 0x8C1B, 0x935D, 0x67D4, 0xF650, 0xDC18, 0x9296, 0xC516,
	0xB60C, 0x64C5, 0xF1C2, 0xECAC, 0xE26D, 0xDD9C, 0x5A79, 0x5388, 0x3CD6,
	0x2900, 0x81D1, 0xB0FE, 0xFF9C, 0x6701, 0xB653, 0xB4B0, 0x1B9E, 0x9970,
	0x443C, 0xEBBD, 0x6223, 0xE524, 0xEBF6, 0x012A, 0x76FA, 0xBC8C, 0xE6D7,
	0xC592, 0xA6CD, 0x7F76, 0x361A, 0xAA0B, 0xFDC6, 0x5C1F, 0x381C, 0x9A59,
	0x3A67, 0x7D7D, 0xBFD9, 0x6257, 0x78A4, 0xD2C9, 0x2AA6, 0x0AA4, 0xB142,
	0xFC51, 0x3031, 0xD88B, 0x6975, 0x297E, 0x68B8, 0xDD35, 0x2EB6, 0xF422,
	0xC587, 0x4012, 0xBAE3, 0x8504, 0x77B6, 0xB086, 0xDC9C, 0x8DAE, 0x0121,
	0xAAD2, 0x7FDA, 0xE377, 0x6BA8, 0x7C43, 0x72D1, 0xC7CD, 0xE2A9, 0x329E,
	0xC308, 0x29C6, 0x2ABC, 0xE2CC, 0xCEB7, 0x6CE8, 0xB3AF, 0xF2C3, 0x6662,
	0x8135, 0x40C3, 0x52B6, 0x9AB5, 0x587B, 0x6326, 0xD17E, 0x12A0, 0x04DC,
	0x42B1, 0xF849, 0x05B4, 0x0C99, 0x70E4, 0x1982, 0x36BE, 0xBF24, 0xC21F,
	0x7F01, 0x8AA2, 0x9766, 0x6924, 0xE375, 0x177B, 0xF74F, 0xD0CB, 0xA310,
	0xC7F2, 0xC89D, 0xF005, 0x4F72, 0xEEDC, 0xCEEE, 0x1414, 0x92D8, 0x6718,
	0xB709, 0x5D0A, 0x8E86, 0x1BA8, 0x2F6A, 0x6881, 0x2073, 0x140F, 0x960E,
	0xE69A, 0xBC35, 0x60EB, 0x077F, 0x1539, 0xC32D, 0x84D4, 0xDB20, 0x5D7F,
	0x87F4, 0x3576, 0xD8BA, 0x8F8A, 0x6906, 0x90EA, 0xB348, 0x786A, 0xAEAE,
	0x235B, 0x9500, 0xCE64, 0x1833, 0x58D7, 0xC8A4, 0xAF6B, 0x4441, 0x3773,
	0xCC09, 0x2DDD, 0x609B, 0x7DA4, 0x57E5, 0xA77B, 0xCD01, 0x80DA, 0x28DE,
	0xE2AD, 0x9D5D, 0x685E, 0x95D1, 0x2DF5, 0x2732, 0xA06F, 0x3F61, 0xFDB1,
	0x0647, 0xA199, 0x64C1, 0xC416, 0x4490, 0x6857, 0xA9C4, 0xFF6A, 0x915E,
	0x38EA, 0x5A23, 0xBA83, 0xB3C9
};


unsigned short calc_packet_key (unsigned char packet_seed,
                                unsigned short enc_state_16,
                                unsigned char enc_state_8)
{
	unsigned int ps = (unsigned int)packet_seed;
	unsigned int table_state;
//	unsigned int ebx;
	int i;

	table_state = (unsigned int) table_1[enc_state_8];
/*
	fprintf (stderr, "  calc_packet_key(): table_state: 0x%04x\n", (int)table_state);
	fprintf (stderr, "  calc_packet_key(): table_2[0x%02x]: 0x%04x\n", ps, (int)table_2[ps]);
	fprintf (stderr, "  calc_packet_key(): table_3[0x%02x]: 0x%04x\n", ps, (int)table_3[ps]);
*/
	for (i = 0; i < 4; i++)
	{
		table_state -= ps * 3;
		table_state += table_2[ps] - table_3[ps];
		table_state += enc_state_16;

/*
		ebx = table_2[ps] - table_3[ps];
		ebx += table_state - (ps * 3);  
		ebx += enc_state_16;            
		table_state = ebx;
*/
//		fprintf (stderr, "  calc_packet_key(): table_state: 0x%04x\n", (int)table_state);
	}

	return (table_state & 0xFFFF);
}

void decrypt_packet (unsigned char *data, int len, unsigned short key)
{
	unsigned char decoded;
	int i;

	for (i = 0; i < len; i++)
	{
		decoded = data[i] ^ (key >> 8);
		key = (key + data[i]) * 0xCE6D + 0x58BF;

		data[i] = decoded;
	}
}	

/*
 * Decrypts packet type 0x33 which contains encryption state. The key is the
 * listening port the connection was made to.
 */
void decrypt_handshake_packet (unsigned char *data, int len, unsigned short key)
{
	unsigned char decoded;
	int i;

	for (i = 0; i < len; i++)
	{
		decoded = data[i] ^ (key >> 8);
		key = (key + data[i]) * 0x5CA0 + 0x15EC;

		data[i] = decoded;
	}
}	


unsigned char get_packet_byte(FILE *fp)
{
	int c;
	
	if((c = fgetc (fp)) == EOF)
		FATAL_ERROR("Unexpected EOF");

	return (unsigned char)c;
}

void print_bin_data(unsigned char *data, int len)
{
	int i;
	int i2;
	int i2_end;

	for (i2 = 0; i2 < len; i2 = i2 + 16)
	{
		i2_end = (i2 + 16 > len) ? len: i2 + 16;
		for (i = i2; i < i2_end; i++)
			if (isprint(data[i]))
				fprintf(stdout, "%c", data[i]);
			else
			fprintf(stdout, ".");
		for ( i = i2_end ; i < i2 + 16; i++)
			fprintf(stdout, " ");
		fprintf(stdout, " | ");
		for (i = i2; i < i2_end; i++)
			fprintf(stdout, "%02x ", data[i]);
		fprintf(stdout, "\n");
	}
}


int main (int argc, char* argv[])
{
	unsigned short port;
	unsigned short enc_state_16 = 0;
	unsigned char enc_state_8 = 0;
	unsigned short packet_len;
	unsigned char packet_type;
	unsigned char packet_seed[2];
	unsigned char packet_body[MAX_PACKET_SIZE];
	unsigned short packet_key;
	unsigned short tmp;
	int i;
	FILE *fp;

	if (argc != 3)
	{
		fprintf (stderr, "Usage: %s <packet file> <supernode port>", argv[0]);
		exit (1);
	}

	if ((fp = fopen (argv[1], "rb")) == NULL)
	{
		fprintf (stderr, "Unable to open file %s\n", argv[1]);
		exit (1);
	}

	port = atoi (argv[2]);

	/* wait for 0x33 packet */

	while (!feof(fp))
	{
		packet_len = get_packet_byte (fp);
		packet_len |= ((unsigned short)get_packet_byte (fp)) << 8;
		packet_type = get_packet_byte (fp);

		if (packet_type == 0x33)
		{
			break;
		}
		else
		{
			fprintf (stderr,
			         "WARNING: Skipping packet of type 0x%02x before 0x33\n",
			         (int)packet_type);
			/* skip packet */
			for (i = 0; i < packet_len; i++)
				get_packet_byte (fp);
		}
	}

	/* handle packet 0x33 */

	if (packet_len > MAX_PACKET_SIZE)
		FATAL_ERROR("Packet too large");

	fprintf (stderr, "Found handshake packet!\n");
	fprintf (stderr, "packet_len: %d (0x%02x)\n", (int)packet_len, (int)packet_len);
	fprintf (stderr, "packet_type: 0x%02x\n", (int)packet_type);

	for (i = 0; i < packet_len; i++)
		packet_body[i] = get_packet_byte (fp);

	if (packet_len < 0x15)
		FATAL_ERROR ("Handshake packet shorter than 0x15");

	printf ("--------------------------------------------------------------------\n");
	print_bin_data (packet_body, packet_len);
	printf ("--------------------------------------------------------------------\n");

	/* decrypt using supplied port */
	decrypt_handshake_packet (packet_body, packet_len, port);

	print_bin_data (packet_body, packet_len);
	printf ("--------------------------------------------------------------------\n");

	/* extract encryption state */
	tmp = packet_body[0];
	tmp |= ((unsigned short)packet_body[1]) << 8;

	fprintf (stderr, "First word of 0x33 packet: 0x%04x\n", (int)tmp);

	if (tmp > 0x015E)
	{
		FATAL_ERROR ("Case tmp > 0x105E unimplemented");
	}

	enc_state_16 = packet_body[0x12];
	enc_state_16 |= ((unsigned short) packet_body[0x13]) << 8;
	enc_state_8 = packet_body[0x14];

	fprintf (stderr, "Extracted encryption state for session!\n");
	fprintf (stderr, "enc_state_16: %d (0x%04x)\n", (int)enc_state_16, (int)enc_state_16);
	fprintf (stderr, "enc_state_8: %d (0x%02x)\n", (int)enc_state_8, (int)enc_state_8);

	fprintf (stderr, "\nDecoding normal packets...\n\n");

while (!feof(fp)) /* hack for processing multiple packets */
{

	packet_len = get_packet_byte (fp);
	packet_len |= ((unsigned short)get_packet_byte (fp)) << 8;

	packet_type = get_packet_byte (fp);

	if (packet_type != 0x32) {
	/* seeds change after two packets in the same direction? */
	packet_seed[0] = get_packet_byte (fp);
	packet_seed[1] = get_packet_byte (fp);
	packet_len -= 2; /* removed packet seeds */
	}
	if (packet_len > MAX_PACKET_SIZE)
		FATAL_ERROR("Packet too large");

	/* read packet body */
	for (i = 0; i < packet_len; i++)
		packet_body[i] = get_packet_byte (fp);

	fprintf (stderr, "packet_len: %d (without 2 bytes of seeds)\n", (int)packet_len);
	fprintf (stderr, "packet_type: 0x%02x\n", (int)packet_type);
	fprintf (stderr, "packet_seed[0]: 0x%02x\n", (int)packet_seed[0]);
	fprintf (stderr, "packet_seed[1]: 0x%02x\n", (int)packet_seed[1]);

	packet_key = calc_packet_key (packet_seed[0], enc_state_16, enc_state_8);

	fprintf (stderr, "packet_key: 0x%04x\n", (int)packet_key);

	/* decrypt and print decrypted packet contents */
	printf ("\n");
	printf ("Packet len:  %-4d (0x%02x) without seed bytes\n", (int)packet_len, (int)packet_len);
	printf ("Packet type: %-4d (0x%02x)\n", (int)packet_type, (int)packet_type);
	printf ("Packet seed: 0x%02x 0x%02x\n", (int)packet_seed[0], (int)packet_seed[1]);
	printf ("--------------------------------------------------------------------\n");
	
	/* print encrypted dump */
	print_bin_data (packet_body, packet_len);

	printf ("--------------------------------------------------------------------\n");
	/* decrypt */
	if (packet_type == 0x32) {
		int q;
		unsigned char uncompressed[123456];
		unsigned long size=sizeof(uncompressed);

//	  	decrypt_handshake_packet (packet_body, packet_len, port);

		if ((q=uncompress (uncompressed, &size, packet_body, packet_len))!=Z_OK)
		{
			printf("q=%d\n",q);
			FATAL_ERROR("zlib decompression failed");
		}

//		print_bin_data (uncompressed, size);
		write(3, uncompressed, size);
	} else {
	  decrypt_packet (packet_body, packet_len, packet_key);

	/* print decrypted dump */
	  print_bin_data (packet_body, packet_len);
	}

	printf ("--------------------------------------------------------------------\n\n");

}

	fclose (fp);
}


